[2024-29-08 19:21:30 INFO] **[Preprocessing]**

**ChatDev Starts** (20240829192130)

**Timestamp**: 20240829192130

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}


**project_name**: RealWorld_BA_112_TopUpAction

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_112_TopUpAction_RealWord_20240829192130.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-29-08 19:21:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:21:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:21:30 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-29-08 19:21:36 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:21:36 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16164
completion_tokens: 201
total_tokens: 16365
cost: $-1.000000


[2024-29-08 19:21:36 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Let's start by analyzing the provided contract code for potential improvements or enhancements. Here are some areas we could focus on:

1. **Gas Optimization**: The contract has several calculations and state updates that could be optimized to reduce gas costs. For example, we could look into minimizing the number of state variable reads and writes, especially in the `execute` function, which is quite complex.

2. **Error Handling**: The contract uses require statements for error handling, which is good, but we could consider implementing custom error messages for better clarity on failures. This would help in debugging and understanding the context of the failure.

3. **Reentrancy Protection**: Although the contract uses `safeTransfer` and `safeApprove`, we should ensure that all external calls are protected against reentrancy attacks. Implementing a reentrancy guard could be beneficial, especially in functions that involve transferring tokens or interacting with external contracts.

4. **Access Control**: The contract uses the `onlyGovernance`

[2024-29-08 19:21:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n    EnumerableSet.AddressSet private _usableTokens;\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n    EnumerableSet.AddressSet internal _usersWithPositions;\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n        return (usersWithPositions, cursor + howMany);\n    }\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n        ExecuteLocalVars memory vars;\n        vars.initialGas = gasleft();\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n        IGasBank gasBank = addressProvider.getGasBank();\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n        ISwapper swapper;\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n        return true;\n    }\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n /\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n    EnumerableSet.AddressSet private _usableTokens;\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n    EnumerableSet.AddressSet internal _usersWithPositions;\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee \n            getEstimatedGasUsage();\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     /\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n    / Set fee handler */\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     /\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     /\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     /\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n    /\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     /\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n        return (usersWithPositions, cursor + howMany);\n    }\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n        ExecuteLocalVars memory vars;\n        vars.initialGas = gasleft();\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n        IGasBank gasBank = addressProvider.getGasBank();\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n        ISwapper swapper;\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n        return true;\n    }\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n    /\n     * @notice returns the current estimated gas usage\n     /\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n    /\n     * @notice Returns the current max swapper slippage\n     */\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n    /\n     * @notice Returns the current fee handler\n     /\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     /\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s start by analyzing the provided contract code for potential improvements or enhancements. Here are some areas we could focus on:\n1. Gas Optimization: The contract has several calculations and state updates that could be optimized to reduce gas costs. For example, we could look into minimizing the number of state variable reads and writes, especially in the execute function, which is quite complex.\n2. Error Handling: The contract uses require statements for error handling, which is good, but we could consider implementing custom error messages for better clarity on failures. This would help in debugging and understanding the context of the failure.\n3. Reentrancy Protection: Although the contract uses safeTransfer and safeApprove, we should ensure that all external calls are protected against reentrancy attacks. Implementing a reentrancy guard could be beneficial, especially in functions that involve transferring tokens or interacting with external contracts.\n4. Access Control*: The contract uses the onlyGovernance', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:21:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:21:37 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";
import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";
/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);
        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }
        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }
        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }
        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }
    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}
contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }
    EnumerableSet.AddressSet private _usableTokens;
    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;
    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";
    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;
    IController public immutable controller;
    IAddressProvider public immutable addressProvider;
    EnumerableSet.Bytes32Set internal _supportedProtocols;
    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;
    mapping(address => RecordMeta[]) internal _userPositions;
    EnumerableSet.AddressSet internal _usersWithPositions;
    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }
    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }
    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }
    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);
        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();
        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);
        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);
        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);
        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);
        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }
    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }
    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }
        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }
    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));
        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }
    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }
    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }
    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }
    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }
    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }
    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }
    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }
    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }
    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }
    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }
    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }
    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }
    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }
    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }
        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }
        return (usersWithPositions_, cursor + howMany);
    }
    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }
    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);
        ExecuteLocalVars memory vars;
        vars.initialGas = gasleft();
        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);
        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);
        IGasBank gasBank = addressProvider.getGasBank();
        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;
        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;
        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );
        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );
        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );
        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();
        ISwapper swapper;
        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }
        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }
        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;
        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);
        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);
        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);
        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }
        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);
        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );
        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);
        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }
        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);
        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }
        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );
        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();
        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }
        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }
        return true;
    }
    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }
    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }
    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }
    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }
    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }
    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }
    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }
    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }
    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }
    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }
    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }
    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }
    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }
    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }
    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }
    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }
    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }
    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";
import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";
import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";
/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;
    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);
        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }
        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }
        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }
        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }
    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}
contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;
    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }
    EnumerableSet.AddressSet private _usableTokens;
    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;
    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";
    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;
    IController public immutable controller;
    IAddressProvider public immutable addressProvider;
    EnumerableSet.Bytes32Set internal _supportedProtocols;
    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;
    mapping(address => RecordMeta[]) internal _userPositions;
    EnumerableSet.AddressSet internal _usersWithPositions;
    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }
    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }
    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }
    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);
        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();
        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);
        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);
        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);
        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);
        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }
    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }
    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }
        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }
    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));
        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }
    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }
    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }
    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }
    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }
    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }
    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }
    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }
    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }
    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }
    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }
    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }
    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }
    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }
    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }
    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }
    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }
        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }
        return (usersWithPositions_, cursor + howMany);
    }
    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }
    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);
        ExecuteLocalVars memory vars;
        vars.initialGas = gasleft();
        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);
        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);
        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);
        IGasBank gasBank = addressProvider.getGasBank();
        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;
        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;
        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );
        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );
        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );
        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();
        ISwapper swapper;
        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }
        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }
        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;
        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);
        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);
        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);
        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }
        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);
        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );
        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);
        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }
        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);
        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }
        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );
        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();
        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }
        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }
        return true;
    }
    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }
    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }
    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }
    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }
    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }
    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }
    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }
    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }
    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }
    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }
    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }
    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }
    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }
    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }
    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }
    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }
    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }
    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }
    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }
    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's start by analyzing the provided contract code for potential improvements or enhancements. Here are some areas we could focus on:
1. **Gas Optimization**: The contract has several calculations and state updates that could be optimized to reduce gas costs. For example, we could look into minimizing the number of state variable reads and writes, especially in the `execute` function, which is quite complex.
2. **Error Handling**: The contract uses require statements for error handling, which is good, but we could consider implementing custom error messages for better clarity on failures. This would help in debugging and understanding the context of the failure.
3. **Reentrancy Protection**: Although the contract uses `safeTransfer` and `safeApprove`, we should ensure that all external calls are protected against reentrancy attacks. Implementing a reentrancy guard could be beneficial, especially in functions that involve transferring tokens or interacting with external contracts.
4. **Access Control**: The contract uses the `onlyGovernance` Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-29-08 19:21:41 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:21:41 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24501
completion_tokens: 1
total_tokens: 24502
cost: $-1.000000


[2024-29-08 19:21:41 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Security

[2024-29-08 19:21:41 INFO] **[Seminar Conclusion]**:

 Security

[2024-29-08 19:21:41 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-29-08 19:21:41 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-29-08 19:21:41 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:21:41 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:21:41 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-29-08 19:21:47 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:21:47 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16155
completion_tokens: 210
total_tokens: 16365
cost: $-1.000000


[2024-29-08 19:21:47 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### VULNERABILITY: Reentrancy Attack
```
The `execute` function allows external calls to the `topUpHandler` via `delegatecall`. If the `topUpHandler` is malicious or has a vulnerability, it could call back into the `TopUpAction` contract before the state changes are completed, potentially leading to unexpected behavior or loss of funds. This is especially concerning since the contract handles funds and state updates.

**Mitigation:** 
Implement a reentrancy guard using a mutex pattern or OpenZeppelin's `ReentrancyGuard` to prevent reentrant calls. Ensure that any state changes occur before external calls.
```

### VULNERABILITY: Gas Limit and Loops
```
The `usersWithPositions` function uses a loop to return users with active positions. If the number of users is large, this could lead to exceeding the gas limit, causing the transaction to fail.

**Mitigation:** 
Implement pagination or limit the number of users returned in a single call. This will help manage

[2024-29-08 19:21:47 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
The `execute` function allows external calls to the `topUpHandler` via `delegatecall`. If the `topUpHandler` is malicious or has a vulnerability, it could call back into the `TopUpAction` contract before the state changes are completed, potentially leading to unexpected behavior or loss of funds. This is especially concerning since the contract handles funds and state updates.

**Mitigation:** 
Implement a reentrancy guard using a mutex pattern or OpenZeppelin's `ReentrancyGuard` to prevent reentrant calls. Ensure that any state changes occur before external calls.
```

### VULNERABILITY: Gas Limit and Loops
```
The `usersWithPositions` function uses a loop to return users with active positions. If the number of users is large, this could lead to exceeding the gas limit, causing the transaction to fail.

**Mitigation:** 
Implement pagination or limit the number of users returned in a single call. This will help manage

[2024-29-08 19:21:47 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-29-08 19:21:47 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:21:47 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:21:47 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-29-08 19:22:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:22:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8137
completion_tokens: 859
total_tokens: 8996
cost: $-1.000000


[2024-29-08 19:22:01 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Based on the provided smart contract code for the `TopUpAction` contract and the associated `TopUpActionLibrary`, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract performs external calls (e.g., `topUpHandler.delegatecall`) which could potentially lead to reentrancy attacks if the called contract is malicious or has vulnerabilities.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that could lead to excessive gas consumption, especially if the number of user positions is large. This could cause transactions to fail due to exceeding the block gas limit.

3. **Insufficient Input Validation**:
   - The contract relies on external contracts for validation (e.g., `getSwapper`, `getHandler`). If these contracts are compromised or behave unexpectedly, it could lead to incorrect assumptions about the state or validity of operations.

4. **Arithmetic Errors**:
   - Although the contract uses `ScaledMath` for safe arithmetic operations, there are still areas where unchecked arithmetic could lead to overflows or underflows, particularly in calculations involving user balances and fees.

5. **Access Control Issues**:
   - The use of `onlyGovernance` modifiers is critical, but if the governance mechanism is compromised, it could allow unauthorized users to change critical parameters like fees and handlers.

6. **Token Approval Issues**:
   - The contract uses `safeApprove` without resetting the allowance to zero first, which can lead to the "approval race condition" vulnerability. This could allow a malicious actor to exploit the allowance before it is updated.

7. **Fallback Function**:
   - The empty `receive()` function does not handle any incoming Ether appropriately, which could lead to unexpected behavior if Ether is sent to the contract.

8. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and debugging of contract interactions.

### Comprehensive Analysis Report

The `TopUpAction` contract is a complex piece of code that integrates various functionalities related to topping up user positions in a decentralized finance (DeFi) context. While it employs several best practices, such as using OpenZeppelin's libraries for safe token transfers and access control, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy**: The potential for reentrancy attacks is a significant concern, especially in DeFi contracts where funds are frequently transferred. Implementing a reentrancy guard or ensuring that state changes occur before external calls can mitigate this risk.

2. **Gas Limit Issues**: The contract should be optimized to avoid excessive gas consumption, particularly in loops. Consider implementing pagination or limiting the number of iterations to ensure that transactions remain within gas limits.

3. **Input Validation**: Strengthening input validation and ensuring that external dependencies are trustworthy is crucial. This includes validating the results of calls to external contracts before proceeding with critical operations.

4. **Arithmetic Safety**: While the use of `ScaledMath` helps, it is essential to review all arithmetic operations to ensure that they are safe from overflow and underflow scenarios.

5. **Access Control**: The governance mechanism must be robust, and additional checks should be implemented to ensure that only authorized users can modify critical parameters.

6. **Token Approval**: To prevent approval race conditions, it is advisable to reset allowances to zero before setting a new allowance. This practice can help mitigate potential exploits.

7. **Fallback Functionality**: The empty `receive()` function should be reconsidered. If the contract is intended to receive Ether, it should handle it appropriately; otherwise, it should be omitted.

8. **Event Emission**: Ensuring that all state changes are accompanied by appropriate event emissions will improve transparency and facilitate easier tracking of contract interactions.

In conclusion, while the `TopUpAction` contract demonstrates a well-structured approach to managing user positions in a DeFi context, it is essential to address the identified vulnerabilities to enhance its security and reliability. A thorough audit and testing process, including unit tests and integration tests, should be conducted to ensure the contract operates as intended without exposing users to unnecessary risks.

[2024-29-08 19:22:01 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `TopUpAction` contract and the associated `TopUpActionLibrary`, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract performs external calls (e.g., `topUpHandler.delegatecall`) which could potentially lead to reentrancy attacks if the called contract is malicious or has vulnerabilities.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that could lead to excessive gas consumption, especially if the number of user positions is large. This could cause transactions to fail due to exceeding the block gas limit.

3. **Insufficient Input Validation**:
   - The contract relies on external contracts for validation (e.g., `getSwapper`, `getHandler`). If these contracts are compromised or behave unexpectedly, it could lead to incorrect assumptions about the state or validity of operations.

4. **Arithmetic Errors**:
   - Although the contract uses `ScaledMath` for safe arithmetic operations, there are still areas where unchecked arithmetic could lead to overflows or underflows, particularly in calculations involving user balances and fees.

5. **Access Control Issues**:
   - The use of `onlyGovernance` modifiers is critical, but if the governance mechanism is compromised, it could allow unauthorized users to change critical parameters like fees and handlers.

6. **Token Approval Issues**:
   - The contract uses `safeApprove` without resetting the allowance to zero first, which can lead to the "approval race condition" vulnerability. This could allow a malicious actor to exploit the allowance before it is updated.

7. **Fallback Function**:
   - The empty `receive()` function does not handle any incoming Ether appropriately, which could lead to unexpected behavior if Ether is sent to the contract.

8. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and debugging of contract interactions.

### Comprehensive Analysis Report

The `TopUpAction` contract is a complex piece of code that integrates various functionalities related to topping up user positions in a decentralized finance (DeFi) context. While it employs several best practices, such as using OpenZeppelin's libraries for safe token transfers and access control, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy**: The potential for reentrancy attacks is a significant concern, especially in DeFi contracts where funds are frequently transferred. Implementing a reentrancy guard or ensuring that state changes occur before external calls can mitigate this risk.

2. **Gas Limit Issues**: The contract should be optimized to avoid excessive gas consumption, particularly in loops. Consider implementing pagination or limiting the number of iterations to ensure that transactions remain within gas limits.

3. **Input Validation**: Strengthening input validation and ensuring that external dependencies are trustworthy is crucial. This includes validating the results of calls to external contracts before proceeding with critical operations.

4. **Arithmetic Safety**: While the use of `ScaledMath` helps, it is essential to review all arithmetic operations to ensure that they are safe from overflow and underflow scenarios.

5. **Access Control**: The governance mechanism must be robust, and additional checks should be implemented to ensure that only authorized users can modify critical parameters.

6. **Token Approval**: To prevent approval race conditions, it is advisable to reset allowances to zero before setting a new allowance. This practice can help mitigate potential exploits.

7. **Fallback Functionality**: The empty `receive()` function should be reconsidered. If the contract is intended to receive Ether, it should handle it appropriately; otherwise, it should be omitted.

8. **Event Emission**: Ensuring that all state changes are accompanied by appropriate event emissions will improve transparency and facilitate easier tracking of contract interactions.

In conclusion, while the `TopUpAction` contract demonstrates a well-structured approach to managing user positions in a DeFi context, it is essential to address the identified vulnerabilities to enhance its security and reliability. A thorough audit and testing process, including unit tests and integration tests, should be conducted to ensure the contract operates as intended without exposing users to unnecessary risks.

[2024-29-08 19:22:01 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-29-08 19:22:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:22:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:22:02 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-29-08 19:22:10 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:22:10 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16155
completion_tokens: 210
total_tokens: 16365
cost: $-1.000000


[2024-29-08 19:22:10 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
The contract does not implement any reentrancy protection mechanisms, such as the Checks-Effects-Interactions pattern or the use of a reentrancy guard. Functions that involve external calls, such as transferring tokens or calling external contracts (e.g., `topUpHandler.delegatecall`), are susceptible to reentrancy attacks. An attacker could exploit this by recursively calling the `execute` function or other functions that modify state, potentially draining funds or manipulating contract state.

**Mitigation:** Implement a reentrancy guard using OpenZeppelin's `ReentrancyGuard` or ensure that all external calls are made after all state changes have been completed. For example, use the `nonReentrant` modifier on functions that can be exploited.
```

### VULNERABILITY 2: Gas Limit and Loops
```
The `usersWithPositions` function uses a loop to return a list of users with active positions. If the number of users is large, this

[2024-29-08 19:22:10 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
The contract does not implement any reentrancy protection mechanisms, such as the Checks-Effects-Interactions pattern or the use of a reentrancy guard. Functions that involve external calls, such as transferring tokens or calling external contracts (e.g., `topUpHandler.delegatecall`), are susceptible to reentrancy attacks. An attacker could exploit this by recursively calling the `execute` function or other functions that modify state, potentially draining funds or manipulating contract state.

**Mitigation:** Implement a reentrancy guard using OpenZeppelin's `ReentrancyGuard` or ensure that all external calls are made after all state changes have been completed. For example, use the `nonReentrant` modifier on functions that can be exploited.
```

### VULNERABILITY 2: Gas Limit and Loops
```
The `usersWithPositions` function uses a loop to return a list of users with active positions. If the number of users is large, this

[2024-29-08 19:22:10 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-29-08 19:22:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:22:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:22:10 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-29-08 19:22:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:22:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8137
completion_tokens: 859
total_tokens: 8996
cost: $-1.000000


[2024-29-08 19:22:23 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Based on the provided Solidity smart contract code, here is a summary of the identified security vulnerabilities and issues:

### Identified Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract performs external calls (e.g., `topUpHandler.delegatecall`) before updating the state variables. This can lead to reentrancy attacks if the external contract is malicious and calls back into the `TopUpAction` contract.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that could potentially lead to exceeding the gas limit if the number of user positions is large. This could cause the transaction to fail.

3. **Insufficient Input Validation**:
   - The contract does not adequately validate the input parameters in several functions, such as `register`, `execute`, and `resetPosition`. This could lead to unexpected behavior or allow malicious actors to exploit the contract.

4. **Lack of Access Control**:
   - While there are some access control mechanisms in place (e.g., `onlyGovernance`), there are functions that can be called by any user without proper restrictions, which could lead to unauthorized actions.

5. **Token Approval Issues**:
   - The `_approve` function uses a max approval pattern, which can lead to the "approval race condition" vulnerability. If a user sets an allowance and then the spender uses it before the user sets it to zero, it can lead to unexpected token transfers.

6. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that are not properly checked could still lead to unexpected results, especially when dealing with user-defined values.

7. **Improper Error Handling**:
   - The contract relies on `require` statements for error handling, but there are cases where the error messages could be more descriptive to aid in debugging and understanding the failure reasons.

8. **Unrestricted Ether Reception**:
   - The `receive()` function is empty, allowing the contract to accept Ether without any restrictions or logging. This could lead to unintentional Ether accumulation.

9. **Lack of Event Emission for Critical State Changes**:
   - While some functions emit events, critical state changes (e.g., when positions are removed or updated) may not trigger events, making it difficult to track changes on-chain.

### Comprehensive Analysis Report:

The `TopUpAction` contract demonstrates a complex structure designed for managing top-up actions in a decentralized finance (DeFi) context. However, several security vulnerabilities have been identified that could compromise the integrity and reliability of the contract.

- **Reentrancy attacks** are a significant concern due to the order of operations in the `execute` function. Implementing a reentrancy guard or following the Checks-Effects-Interactions pattern can mitigate this risk.
  
- **Gas limit issues** could arise from loops in functions that handle user positions, potentially leading to transaction failures. Optimizing these loops or implementing pagination can help manage gas consumption effectively.

- **Input validation** needs to be strengthened across various functions to prevent unexpected behavior and ensure that only valid data is processed.

- **Access control** mechanisms should be reviewed to ensure that only authorized users can perform sensitive operations, thereby reducing the risk of unauthorized actions.

- **Token approval patterns** should be revised to avoid the approval race condition, which can lead to token theft.

- While Solidity's built-in protections against overflow/underflow are beneficial, developers should remain vigilant about arithmetic operations and ensure proper checks are in place.

- **Error handling** can be improved by providing more informative error messages, aiding in debugging and user experience.

- The **empty receive function** poses a risk of unintentional Ether accumulation, which should be addressed by either implementing restrictions or logging.

- Finally, ensuring that critical state changes are accompanied by event emissions will enhance transparency and traceability within the contract.

In conclusion, while the `TopUpAction` contract has a robust framework for managing top-up actions, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract in a production environment. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-29-08 19:22:23 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code, here is a summary of the identified security vulnerabilities and issues:

### Identified Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract performs external calls (e.g., `topUpHandler.delegatecall`) before updating the state variables. This can lead to reentrancy attacks if the external contract is malicious and calls back into the `TopUpAction` contract.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that could potentially lead to exceeding the gas limit if the number of user positions is large. This could cause the transaction to fail.

3. **Insufficient Input Validation**:
   - The contract does not adequately validate the input parameters in several functions, such as `register`, `execute`, and `resetPosition`. This could lead to unexpected behavior or allow malicious actors to exploit the contract.

4. **Lack of Access Control**:
   - While there are some access control mechanisms in place (e.g., `onlyGovernance`), there are functions that can be called by any user without proper restrictions, which could lead to unauthorized actions.

5. **Token Approval Issues**:
   - The `_approve` function uses a max approval pattern, which can lead to the "approval race condition" vulnerability. If a user sets an allowance and then the spender uses it before the user sets it to zero, it can lead to unexpected token transfers.

6. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, any arithmetic operations that are not properly checked could still lead to unexpected results, especially when dealing with user-defined values.

7. **Improper Error Handling**:
   - The contract relies on `require` statements for error handling, but there are cases where the error messages could be more descriptive to aid in debugging and understanding the failure reasons.

8. **Unrestricted Ether Reception**:
   - The `receive()` function is empty, allowing the contract to accept Ether without any restrictions or logging. This could lead to unintentional Ether accumulation.

9. **Lack of Event Emission for Critical State Changes**:
   - While some functions emit events, critical state changes (e.g., when positions are removed or updated) may not trigger events, making it difficult to track changes on-chain.

### Comprehensive Analysis Report:

The `TopUpAction` contract demonstrates a complex structure designed for managing top-up actions in a decentralized finance (DeFi) context. However, several security vulnerabilities have been identified that could compromise the integrity and reliability of the contract.

- **Reentrancy attacks** are a significant concern due to the order of operations in the `execute` function. Implementing a reentrancy guard or following the Checks-Effects-Interactions pattern can mitigate this risk.
  
- **Gas limit issues** could arise from loops in functions that handle user positions, potentially leading to transaction failures. Optimizing these loops or implementing pagination can help manage gas consumption effectively.

- **Input validation** needs to be strengthened across various functions to prevent unexpected behavior and ensure that only valid data is processed.

- **Access control** mechanisms should be reviewed to ensure that only authorized users can perform sensitive operations, thereby reducing the risk of unauthorized actions.

- **Token approval patterns** should be revised to avoid the approval race condition, which can lead to token theft.

- While Solidity's built-in protections against overflow/underflow are beneficial, developers should remain vigilant about arithmetic operations and ensure proper checks are in place.

- **Error handling** can be improved by providing more informative error messages, aiding in debugging and user experience.

- The **empty receive function** poses a risk of unintentional Ether accumulation, which should be addressed by either implementing restrictions or logging.

- Finally, ensuring that critical state changes are accompanied by event emissions will enhance transparency and traceability within the contract.

In conclusion, while the `TopUpAction` contract has a robust framework for managing top-up actions, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract in a production environment. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-29-08 19:22:23 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-29-08 19:22:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:22:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:22:24 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-29-08 19:22:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:22:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16155
completion_tokens: 210
total_tokens: 16365
cost: $-1.000000


[2024-29-08 19:22:29 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The `execute` function uses a delegate call to the top-up handler, which can potentially lead to a reentrancy attack if the handler is not designed to prevent it. If the handler calls back into the `TopUpAction` contract before the state changes are finalized, it could manipulate the state in an unexpected way, leading to loss of funds or incorrect balances.

RECOMMENDED MITIGATION: Implement the Checks-Effects-Interactions pattern. Ensure that all state changes are made before any external calls (like delegate calls) are executed. Additionally, consider using a reentrancy guard modifier to prevent reentrant calls to sensitive functions.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `usersWithPositions` function uses a loop to return a list of users with active positions. If the number of users is large, this could lead to exceeding the block gas limit, causing the transaction to fail.



[2024-29-08 19:22:29 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The `execute` function uses a delegate call to the top-up handler, which can potentially lead to a reentrancy attack if the handler is not designed to prevent it. If the handler calls back into the `TopUpAction` contract before the state changes are finalized, it could manipulate the state in an unexpected way, leading to loss of funds or incorrect balances.

RECOMMENDED MITIGATION: Implement the Checks-Effects-Interactions pattern. Ensure that all state changes are made before any external calls (like delegate calls) are executed. Additionally, consider using a reentrancy guard modifier to prevent reentrant calls to sensitive functions.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The `usersWithPositions` function uses a loop to return a list of users with active positions. If the number of users is large, this could lead to exceeding the block gas limit, causing the transaction to fail.



[2024-29-08 19:22:29 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-29-08 19:22:29 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 19:22:29 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:22:29 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-29-08 19:22:39 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:22:39 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8137
completion_tokens: 615
total_tokens: 8752
cost: $-1.000000


[2024-29-08 19:22:39 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls (e.g., `topUpHandler.delegatecall`) before updating the state variables. This could allow an attacker to re-enter the function and manipulate the state in an unintended manner.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that can potentially lead to exceeding the gas limit if the number of user positions is large. This could result in a denial of service.

3. **Insufficient Input Validation**:
   - The contract lacks thorough validation for certain inputs, such as the `maxFee` and `singleTopUpAmount`, which could allow for unexpected behavior if incorrect values are provided.

4. **Token Approval Issues**:
   - The `_approve` function does not handle the case where the allowance is already set to the maximum value. This could lead to unnecessary gas consumption and potential issues if the token contract has a non-standard implementation.

5. **Arithmetic Issues**:
   - The contract uses division and multiplication without proper checks for zero values, which could lead to division by zero errors or unexpected results due to integer overflow/underflow.

6. **Access Control**:
   - The contract relies on governance for critical functions but does not implement a robust mechanism to ensure that only authorized users can call sensitive functions. This could lead to unauthorized access and manipulation of contract state.

7. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract interactions.

8. **Potential for Front-Running**:
   - The contract does not implement measures to prevent front-running attacks, where an attacker could observe pending transactions and exploit them for profit.

### Comprehensive Analysis Report

The provided smart contract exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issue is the potential for reentrancy attacks, which could lead to significant financial losses. Additionally, the contract's reliance on external calls without proper state updates increases the risk of unexpected behavior.

The gas limit concerns in loops could lead to denial of service, especially in scenarios with a high number of user positions. Insufficient input validation could allow for unexpected contract behavior, while token approval issues could lead to unnecessary gas consumption and potential failures in token transfers.

Arithmetic operations lack proper checks, which could lead to errors that compromise the contract's integrity. Furthermore, the access control mechanisms are not robust enough to prevent unauthorized access, posing a risk to sensitive functions.

The absence of event emissions in certain functions limits the ability to track contract interactions, making it difficult to audit and monitor the contract's state changes. Lastly, the potential for front-running attacks highlights the need for additional protective measures to ensure fair transaction processing.

In conclusion, while the contract implements several useful features, it is crucial to address these vulnerabilities to enhance security and protect user funds. A thorough audit and implementation of best practices in smart contract development are recommended to mitigate these risks effectively.

[2024-29-08 19:22:39 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls (e.g., `topUpHandler.delegatecall`) before updating the state variables. This could allow an attacker to re-enter the function and manipulate the state in an unintended manner.

2. **Gas Limit and Loops**:
   - The `execute` function contains loops that can potentially lead to exceeding the gas limit if the number of user positions is large. This could result in a denial of service.

3. **Insufficient Input Validation**:
   - The contract lacks thorough validation for certain inputs, such as the `maxFee` and `singleTopUpAmount`, which could allow for unexpected behavior if incorrect values are provided.

4. **Token Approval Issues**:
   - The `_approve` function does not handle the case where the allowance is already set to the maximum value. This could lead to unnecessary gas consumption and potential issues if the token contract has a non-standard implementation.

5. **Arithmetic Issues**:
   - The contract uses division and multiplication without proper checks for zero values, which could lead to division by zero errors or unexpected results due to integer overflow/underflow.

6. **Access Control**:
   - The contract relies on governance for critical functions but does not implement a robust mechanism to ensure that only authorized users can call sensitive functions. This could lead to unauthorized access and manipulation of contract state.

7. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract interactions.

8. **Potential for Front-Running**:
   - The contract does not implement measures to prevent front-running attacks, where an attacker could observe pending transactions and exploit them for profit.

### Comprehensive Analysis Report

The provided smart contract exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issue is the potential for reentrancy attacks, which could lead to significant financial losses. Additionally, the contract's reliance on external calls without proper state updates increases the risk of unexpected behavior.

The gas limit concerns in loops could lead to denial of service, especially in scenarios with a high number of user positions. Insufficient input validation could allow for unexpected contract behavior, while token approval issues could lead to unnecessary gas consumption and potential failures in token transfers.

Arithmetic operations lack proper checks, which could lead to errors that compromise the contract's integrity. Furthermore, the access control mechanisms are not robust enough to prevent unauthorized access, posing a risk to sensitive functions.

The absence of event emissions in certain functions limits the ability to track contract interactions, making it difficult to audit and monitor the contract's state changes. Lastly, the potential for front-running attacks highlights the need for additional protective measures to ensure fair transaction processing.

In conclusion, while the contract implements several useful features, it is crucial to address these vulnerabilities to enhance security and protect user funds. A thorough audit and implementation of best practices in smart contract development are recommended to mitigate these risks effectively.

[2024-29-08 19:22:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n\nimport "../../../interfaces/IGasBank.sol";\nimport "../../../interfaces/pool/ILiquidityPool.sol";\nimport "../../../interfaces/ISwapperRegistry.sol";\nimport "../../../interfaces/IController.sol";\nimport "../../../interfaces/IStakerVault.sol";\nimport "../../../interfaces/ISwapper.sol";\nimport "../../../interfaces/actions/topup/ITopUpHandler.sol";\nimport "../../../interfaces/actions/topup/ITopUpAction.sol";\nimport "../../../interfaces/actions/IActionFeeHandler.sol";\n\nimport "../../../libraries/AddressProviderHelpers.sol";\nimport "../../../libraries/Errors.sol";\nimport "../../../libraries/ScaledMath.sol";\nimport "../../../libraries/EnumerableExtensions.sol";\n\nimport "../../access/Authorization.sol";\nimport "../../utils/Preparable.sol";\n\n/\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount &gt; 0) {\n            depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft &gt; 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance &lt; allowance ? balance : allowance;\n            if (availableFunds &gt;= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being "too deep"\n     /\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";\n    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record)\n    mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;\n\n    mapping(address =&gt; RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i &lt; protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /\n     * @notice Register a top up action.\n     * @dev The depositAmount must be greater or equal to the totalTopUpAmount (which is denominated in actionToken).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of depositToken that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     /\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);\n        require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) \n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /\n     * @notice See overloaded version of execute for more details.\n     /\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /\n     * @notice Delete a position to back on the given protocol for account.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return true if successful.\n     /\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return true if successful.\n     /\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return true if success.\n     /\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return true if success.\n     /\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;\n                newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return true if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /\n     * @notice Reset action fee deadline.\n     * @return true if successful.\n     /\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    / Set fee handler /\n    /\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return true if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return true if successful.\n     /\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Reset the handler deadline.\n     * @return true if success.\n     /\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return true if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return true if successful.\n     /\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Reset the gas usage deadline.\n     * @return true if success.\n     /\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     /\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /\n     * @notice Returns a list of positions for the given payer\n     /\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     /\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32;\n        for (uint256 i = 0; i &lt; length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = usersWithPositions.length();\n        if (cursor &gt;= length) return (new address, 0);\n        if (howMany &gt;= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions = new address;\n        for (uint256 i = 0; i &lt; howMany; i++) {\n            usersWithPositions_[i] = usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions, cursor + howMany);\n    }\n\n    /\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     /\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /\n     * @notice Retrieves the topup handler for the given protocol\n     /\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice Successfully tops up a position if it\'s conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper\'s wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return true if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas &lt;=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly vars.actionTokenAmount\n        // (at least position.singleTopUpAmount) of action token\n        // and exactly vars.depositTotalFeesAmount deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                "topUp(bytes32,address,uint256,bytes)",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new "balance" of the position\n        if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance &gt; 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return true if success.\n     /\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     /\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current action fee\n     /\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /\n     * @notice Returns the current max swapper slippage\n     /\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     /\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     /\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who\'s position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /\n     * @dev "Locks" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of token to lock\n     * @param depositAmount Amount of token that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than requiredAmount more tokens will be locked.\n     /\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i &lt; length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     /\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) &gt; 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /*\n     * @dev Computes and returns the amount of LP tokens of type token that will be received in exchange for an amount of the underlying.\n     /\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-29-08 19:22:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.9; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; import "../../../interfaces/IGasBank.sol"; import "../../../interfaces/pool/ILiquidityPool.sol"; import "../../../interfaces/ISwapperRegistry.sol"; import "../../../interfaces/IController.sol"; import "../../../interfaces/IStakerVault.sol"; import "../../../interfaces/ISwapper.sol"; import "../../../interfaces/actions/topup/ITopUpHandler.sol"; import "../../../interfaces/actions/topup/ITopUpAction.sol"; import "../../../interfaces/actions/IActionFeeHandler.sol"; import "../../../libraries/AddressProviderHelpers.sol"; import "../../../libraries/Errors.sol"; import "../../../libraries/ScaledMath.sol"; import "../../../libraries/EnumerableExtensions.sol"; import "../../access/Authorization.sol"; import "../../utils/Preparable.sol"; /*  * @notice The logic here should really be part of the top-up action  * but is split in a library to circumvent the byte-code size limit  / library TopUpActionLibrary {     using SafeERC20 for IERC20;     using ScaledMath for uint256;     using AddressProviderHelpers for IAddressProvider; function lockFunds(     address stakerVaultAddress,     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) external {     uint256 amountLeft = lockAmount;     IStakerVault stakerVault = IStakerVault(stakerVaultAddress);      // stake deposit amount     if (depositAmount &gt; 0) {         depositAmount = depositAmount &gt; amountLeft ? amountLeft : depositAmount;         IERC20(token).safeTransferFrom(payer, address(this), depositAmount);         IERC20(token).safeApprove(stakerVaultAddress, depositAmount);         stakerVault.stake(depositAmount);         stakerVault.increaseActionLockedBalance(payer, depositAmount);         amountLeft -= depositAmount;     }      // use stake vault allowance if available and required     if (amountLeft &gt; 0) {         uint256 balance = stakerVault.balanceOf(payer);         uint256 allowance = stakerVault.allowance(payer, address(this));         uint256 availableFunds = balance &lt; allowance ? balance : allowance;         if (availableFunds &gt;= amountLeft) {             stakerVault.transferFrom(payer, address(this), amountLeft);             amountLeft = 0;         }     }      require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function calcExchangeAmount(     IAddressProvider addressProvider,     address token,     address actionToken,     uint256 amount ) external view returns (uint256) {     ILiquidityPool pool = addressProvider.getPoolForToken(token);     uint256 rate = pool.exchangeRate();     address underlying = pool.getUnderlying();     if (underlying == actionToken) {         return amount.scaledDivRoundUp(rate);     }      ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);     uint256 swapperRate = swapper.getRate(underlying, actionToken);     return amount.scaledDivRoundUp(rate.scaledMul(swapperRate)); }  function getSwapper(     IAddressProvider addressProvider,     address underlying,     address actionToken ) public view returns (ISwapper) {     address swapperRegistry = addressProvider.getSwapperRegistry();     address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);     require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);     return ISwapper(swapper); }  } contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {     using ScaledMath for uint256;     using ScaledMath for uint128;     using SafeERC20 for IERC20;     using EnumerableSet for EnumerableSet.AddressSet;     using EnumerableSet for EnumerableSet.Bytes32Set;     using EnumerableExtensions for EnumerableSet.AddressSet;     using AddressProviderHelpers for IAddressProvider; /**  * @dev Temporary struct to hold local variables in execute  * and avoid the stack being "too deep"  */ struct ExecuteLocalVars {     uint256 minActionAmountToTopUp;     uint256 actionTokenAmount;     uint256 depositTotalFeesAmount;     uint256 actionAmountWithFees;     uint256 userFactor;     uint256 rate;     uint256 depositAmountWithFees;     uint256 depositAmountWithoutFees;     uint256 actionFee;     uint256 totalActionTokenAmount;     uint128 totalTopUpAmount;     bool success;     bytes topupResult;     uint256 gasBankBalance;     uint256 initialGas;     uint256 gasConsumed;     uint256 userGasPrice;     uint256 estimatedRequiredGas;     uint256 estimatedRequiredWeiForGas;     uint256 requiredWeiForGas;     uint256 reimbursedWeiForGas;     address underlying;     bool removePosition; }  EnumerableSet.AddressSet private _usableTokens;  uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;  bytes32 internal constant _ACTION_FEE_KEY = "ActionFee"; bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler"; bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler"; bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage"; bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";  uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18; uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18; uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;  IController public immutable controller; IAddressProvider public immutable addressProvider;  EnumerableSet.Bytes32Set internal _supportedProtocols;  /// @notice mapping of (payer -&gt; account -&gt; protocol -&gt; Record) mapping(address =&gt; mapping(bytes32 =&gt; mapping(bytes32 =&gt; Record))) private _positions;  mapping(address =&gt; RecordMeta[]) internal _userPositions;  EnumerableSet.AddressSet internal _usersWithPositions;  constructor(IController _controller)     Authorization(_controller.addressProvider().getRoleManager()) {     controller = _controller;     addressProvider = controller.addressProvider();     _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE); }  receive() external payable {     // solhint-disable-previous-line no-empty-blocks }  function initialize(     address feeHandler,     bytes32[] calldata protocols,     address[] calldata handlers ) external initializer onlyGovernance {     require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);     _setConfig(_FEE_HANDLER_KEY, feeHandler);     _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);     for (uint256 i = 0; i &lt; protocols.length; i++) {         bytes32 protocolKey = _getProtocolKey(protocols[i]);         _setConfig(protocolKey, handlers[i]);         _updateTopUpHandler(protocols[i], address(0), handlers[i]);     } }  /**  * @notice Register a top up action.  * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).  * @param account Account to be topped up (first 20 bytes will typically be the address).  * @param depositAmount Amount of `depositToken` that will be locked.  * @param protocol Protocol which holds position to be topped up.  * @param record containing the data for the position to register  */ function register(     bytes32 account,     bytes32 protocol,     uint128 depositAmount,     Record memory record ) external payable returns (bool) {     require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);     require(record.singleTopUpAmount &gt; 0, Error.INVALID_AMOUNT);     require(record.threshold &gt; ScaledMath.ONE, Error.INVALID_AMOUNT);     require(record.singleTopUpAmount &lt;= record.totalTopUpAmount, Error.INVALID_AMOUNT);     require(         _positions[msg.sender][account][protocol].threshold == 0,         Error.POSITION_ALREADY_EXISTS     );     require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);     require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);      uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *         record.maxFee *         getEstimatedGasUsage();      require(msg.value &gt;= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);      uint256 totalLockAmount = _calcExchangeAmount(         record.depositToken,         record.actionToken,         record.totalTopUpAmount     );     _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);      addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);      record.depositTokenBalance = uint128(totalLockAmount);     _positions[msg.sender][account][protocol] = record;     _userPositions[msg.sender].push(RecordMeta(account, protocol));     _usersWithPositions.add(msg.sender);      emit Register(         account,         protocol,         record.threshold,         msg.sender,         record.depositToken,         totalLockAmount,         record.actionToken,         record.singleTopUpAmount,         record.totalTopUpAmount,         record.maxFee,         record.extra     );     return true; }  /**  * @notice See overloaded version of `execute` for more details.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol ) external override returns (bool) {     return execute(payer, account, beneficiary, protocol, 0); }  /**  * @notice Delete a position to back on the given protocol for `account`.  * @param account Account holding the position.  * @param protocol Protocol the position is held on.  * @param unstake If the tokens should be unstaked from vault.  * @return `true` if successful.  */ function resetPosition(     bytes32 account,     bytes32 protocol,     bool unstake ) external override returns (bool) {     address payer = msg.sender;     Record memory position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);      address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist     IStakerVault staker = IStakerVault(vault);     staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);     if (unstake) {         staker.unstake(position.depositTokenBalance);         IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);     } else {         staker.transfer(payer, position.depositTokenBalance);     }      _removePosition(payer, account, protocol);     addressProvider.getGasBank().withdrawUnused(payer);     return true; }  /**  * @notice Execute top up handler update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @param protocol Protocol for which a new handler should be executed.  * @return Address of new handler.  */ function executeTopUpHandler(bytes32 protocol) external override returns (address) {     address oldHandler = _getHandler(protocol, false);     address newHandler = _executeAddress(_getProtocolKey(protocol));      _updateTopUpHandler(protocol, oldHandler, newHandler);     return newHandler; }  /**  * @notice Reset new top up handler deadline for a protocol.  * @param protocol Protocol for which top up handler deadline should be reset.  * @return `true` if successful.  */ function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {     return _resetAddressConfig(_getProtocolKey(protocol)); }  /**  * @notice Prepare action fee update.  * @param newActionFee New fee to set.  * @return `true` if success.  */ function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {     require(newActionFee &lt;= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);     return _prepare(_ACTION_FEE_KEY, newActionFee); }  /**  * @notice Execute action fee update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeActionFee() external override returns (uint256) {     return _executeUInt256(_ACTION_FEE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetActionFee() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ACTION_FEE_KEY); }  /**  * @notice Prepare swapper slippage update.  * @param newSwapperSlippage New slippage to set.  * @return `true` if success.  */ function prepareSwapperSlippage(uint256 newSwapperSlippage)     external     onlyGovernance     returns (bool) {     require(         newSwapperSlippage &gt;= _MIN_SWAPPER_SLIPPAGE &amp;&amp;             newSwapperSlippage &lt;= _MAX_SWAPPER_SLIPPAGE,         Error.INVALID_AMOUNT     );     return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage); }  /**  * @notice Execute swapper slippage update (with time delay enforced).  * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeSwapperSlippage() external override returns (uint256) {     return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY); }  /**  * @notice Reset action fee deadline.  * @return `true` if successful.  */ function resetSwapperSlippage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY); }  /** Set fee handler */ /**  * @notice Prepare update of fee handler.  * @param handler New fee handler.  * @return `true` if success.  */ function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {     return _prepare(_FEE_HANDLER_KEY, handler); }  /**  * @notice Execute update of fee handler (with time delay enforced).  * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.  * @return `true` if successful.  */ function executeFeeHandler() external override returns (address) {     return _executeAddress(_FEE_HANDLER_KEY); }  /**  * @notice Reset the handler deadline.  * @return `true` if success.  */ function resetFeeHandler() external onlyGovernance returns (bool) {     return _resetAddressConfig(_FEE_HANDLER_KEY); }  /**  * @notice Prepare update of estimated gas usage.  * @param gasUsage New estimated gas usage.  * @return `true` if success.  */ function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {     return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage); }  /**  * @notice Execute update of gas usage (with time delay enforced).  * @return `true` if successful.  */ function executeEstimatedGasUsage() external returns (uint256) {     return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Reset the gas usage deadline.  * @return `true` if success.  */ function resetGasUsage() external onlyGovernance returns (bool) {     return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY); }  /**  * @notice Add a new deposit token that is supported by the action.  * @dev There is a separate check for whether the usable token (i.e. deposit token)  *      is swappable for some action token.  * @param token Address of deposit token that can be used by the action.  */ function addUsableToken(address token) external override onlyGovernance returns (bool) {     return _usableTokens.add(token); }  /**  * @notice Computes the total amount of ETH (as wei) required to pay for all  * the top-ups assuming the maximum gas price and the current estimated gas  * usage of a top-up  */ function getEthRequiredForGas(address payer) external view override returns (uint256) {     uint256 totalEthRequired = 0;     RecordMeta[] memory userRecordsMeta = _userPositions[payer];     uint256 gasUsagePerCall = getEstimatedGasUsage();     uint256 length = userRecordsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta memory meta = userRecordsMeta[i];         Record memory record = _positions[payer][meta.account][meta.protocol];         uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);         totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;     }     return totalEthRequired; }  /**  * @notice Returns a list of positions for the given payer  */ function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {     return _userPositions[payer]; }  /**  * @notice Get a list supported protocols.  * @return List of supported protocols.  */ function getSupportedProtocols() external view override returns (bytes32[] memory) {     uint256 length = _supportedProtocols.length();     bytes32[] memory protocols = new bytes32[](length);     for (uint256 i = 0; i &lt; length; i++) {         protocols[i] = _supportedProtocols.at(i);     }     return protocols; }  /*  * @notice Gets a list of users that have an active position.  * @dev Uses cursor pagination.  * @param cursor The cursor for pagination (should start at 0 for first call).  * @param howMany Maximum number of users to return in this pagination request.  * @return users List of users that have an active position.  * @return nextCursor The cursor to use for the next pagination request.  */ function usersWithPositions(uint256 cursor, uint256 howMany)     external     view     override     returns (address[] memory users, uint256 nextCursor) {     uint256 length = _usersWithPositions.length();     if (cursor &gt;= length) return (new address[](0), 0);     if (howMany &gt;= length - cursor) {         howMany = length - cursor;     }      address[] memory usersWithPositions_ = new address[](howMany);     for (uint256 i = 0; i &lt; howMany; i++) {         usersWithPositions_[i] = _usersWithPositions.at(i + cursor);     }      return (usersWithPositions_, cursor + howMany); }  /**  * @notice Get a list of all tokens usable for this action.  * @dev This refers to all tokens that can be used as deposit tokens.  * @return Array of addresses of usable tokens.  */ function getUsableTokens() external view override returns (address[] memory) {     return _usableTokens.toArray(); }  /**  * @notice Retrieves the topup handler for the given `protocol`  */ function getTopUpHandler(bytes32 protocol) external view returns (address) {     return _getHandler(protocol, false); }  /**  * @notice Successfully tops up a position if it's conditions are met.  * @dev pool and vault funds are rebalanced after withdrawal for top up  * @param payer Account that pays for the top up.  * @param account Account owning the position for top up.  * @param beneficiary Address of the keeper's wallet for fee accrual.  * @param protocol Protocol of the top up position.  * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas  * @return `true` if successful.  */ function execute(     address payer,     bytes32 account,     address beneficiary,     bytes32 protocol,     uint256 maxWeiForGas ) public override returns (bool) {     require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);      ExecuteLocalVars memory vars;      vars.initialGas = gasleft();      Record storage position = _positions[payer][account][protocol];     require(position.threshold != 0, Error.NO_POSITION_EXISTS);     require(position.totalTopUpAmount &gt; 0, Error.INSUFFICIENT_BALANCE);      address topUpHandler = _getHandler(protocol, true);     vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);      // ensure that the position is actually below its set user factor threshold     require(vars.userFactor &lt; position.threshold, Error.INSUFFICIENT_THRESHOLD);      IGasBank gasBank = addressProvider.getGasBank();      // fail early if the user does not have enough funds in the gas bank     // to cover the cost of the transaction     vars.estimatedRequiredGas = getEstimatedGasUsage();     vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;      // compute the gas price that the user will be paying     vars.userGasPrice = block.basefee + position.priorityFee;     if (vars.userGasPrice &gt; tx.gasprice) vars.userGasPrice = tx.gasprice;     if (vars.userGasPrice &gt; position.maxFee) vars.userGasPrice = position.maxFee;      // ensure the current position allows for the gas to be paid     require(         vars.estimatedRequiredWeiForGas &lt;=             vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,         Error.ESTIMATED_GAS_TOO_HIGH     );      vars.gasBankBalance = gasBank.balanceOf(payer);     // ensure the user has enough funds in the gas bank to cover the gas     require(         vars.gasBankBalance + maxWeiForGas &gt;= vars.estimatedRequiredWeiForGas,         Error.GAS_BANK_BALANCE_TOO_LOW     );      vars.totalTopUpAmount = position.totalTopUpAmount;     vars.actionFee = getActionFee();     // add top-up fees to top-up amount     vars.minActionAmountToTopUp = position.singleTopUpAmount;     vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(         ScaledMath.ONE + vars.actionFee     );      // if the amount that we want to top-up (including fees) is higher than     // the available topup amount, we lower this down to what is left of the position     if (vars.actionAmountWithFees &gt; vars.totalTopUpAmount) {         vars.actionAmountWithFees = vars.totalTopUpAmount;         vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(             ScaledMath.ONE + vars.actionFee         );     }     ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);     vars.underlying = pool.getUnderlying();     vars.rate = pool.exchangeRate();      ISwapper swapper;      if (vars.underlying != position.actionToken) {         swapper = _getSwapper(vars.underlying, position.actionToken);         vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));     }      // compute the deposit tokens amount with and without fees     // we will need to unstake the amount with fees and to     // swap the amount without fees into action tokens     vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);     if (position.depositTokenBalance &lt; vars.depositAmountWithFees) {         vars.depositAmountWithFees = position.depositTokenBalance;         vars.minActionAmountToTopUp =             (vars.depositAmountWithFees * vars.rate) /             (ScaledMath.ONE + vars.actionFee);     }      // compute amount of LP tokens needed to pay for action     // rate is expressed in actionToken per depositToken     vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);     vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;      // will revert if vault does not exist     address vault = addressProvider.getStakerVault(position.depositToken);      // unstake deposit tokens including fees     IStakerVault(vault).unstake(vars.depositAmountWithFees);     IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);      // swap the amount without the fees     // as the fees are paid in deposit token, not in action token     // Redeem first and use swapper only if the underlying tokens are not action tokens     vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);      if (address(swapper) != address(0)) {         vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(             getSwapperSlippage()         );         _approve(vars.underlying, address(swapper));         vars.actionTokenAmount = swapper.swap(             vars.underlying,             position.actionToken,             vars.actionTokenAmount,             vars.minActionAmountToTopUp         );     }      // compute how much of action token was actually redeemed and add fees to it     // this is to ensure that no funds get locked inside the contract     vars.totalActionTokenAmount =         vars.actionTokenAmount +         vars.depositTotalFeesAmount.scaledMul(vars.rate);      // at this point, we have exactly `vars.actionTokenAmount`     // (at least `position.singleTopUpAmount`) of action token     // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract     // solhint-disable-next-line avoid-low-level-calls     (vars.success, vars.topupResult) = topUpHandler.delegatecall(         abi.encodeWithSignature(             "topUp(bytes32,address,uint256,bytes)",             account,             position.actionToken,             vars.actionTokenAmount,             position.extra         )     );      require(vars.success &amp;&amp; abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);      // totalTopUpAmount is updated to reflect the new "balance" of the position     if (vars.totalTopUpAmount &gt; vars.totalActionTokenAmount) {         position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);     } else {         position.totalTopUpAmount = 0;     }      position.depositTokenBalance -= uint128(vars.depositAmountWithFees);      vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;     _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);     if (vars.removePosition) {         if (position.depositTokenBalance &gt; 0) {             // transfer any unused locked tokens to the payer             IStakerVault(vault).transfer(payer, position.depositTokenBalance);             IStakerVault(vault).decreaseActionLockedBalance(                 payer,                 position.depositTokenBalance             );         }         _removePosition(payer, account, protocol);     }      emit TopUp(         account,         protocol,         payer,         position.depositToken,         vars.depositAmountWithFees,         position.actionToken,         vars.actionTokenAmount     );      // compute gas used and reimburse the keeper by using the     // funds of payer in the gas bank     // TODO: add constant gas consumed for transfer and tx prologue     vars.gasConsumed = vars.initialGas - gasleft();      vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;     if (vars.reimbursedWeiForGas &gt; vars.gasBankBalance) {         vars.reimbursedWeiForGas = vars.gasBankBalance;     }      // ensure that the keeper is not overpaying     vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;     require(         vars.reimbursedWeiForGas + maxWeiForGas &gt;= vars.requiredWeiForGas,         Error.GAS_TOO_HIGH     );     gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);     if (vars.removePosition) {         gasBank.withdrawUnused(payer);     }      return true; }  /**  * @notice Prepare new top up handler fee update.  * @dev Setting the addres to 0 means that the protocol will no longer be supported.  * @param protocol Protocol for which a new handler should be prepared.  * @param newHandler Address of new handler.  * @return `true` if success.  */ function prepareTopUpHandler(bytes32 protocol, address newHandler)     public     onlyGovernance     returns (bool) {     return _prepare(_getProtocolKey(protocol), newHandler); }  /**  * @notice Check if action can be executed.  * @param protocol for which to get the health factor  * @param account for which to get the health factor  * @param extra data to be used by the topup handler  * @return healthFactor of the position  */ function getHealthFactor(     bytes32 protocol,     bytes32 account,     bytes memory extra ) public view override returns (uint256 healthFactor) {     ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));     return topUpHandler.getUserFactor(account, extra); }  function getHandler(bytes32 protocol) public view override returns (address) {     return _getHandler(protocol, false); }  /**  * @notice returns the current estimated gas usage  */ function getEstimatedGasUsage() public view returns (uint256) {     return currentUInts256[_ESTIMATED_GAS_USAGE_KEY]; }  /**  * @notice Returns the current action fee  */ function getActionFee() public view override returns (uint256) {     return currentUInts256[_ACTION_FEE_KEY]; }  /**  * @notice Returns the current max swapper slippage  */ function getSwapperSlippage() public view override returns (uint256) {     return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY]; }  /**  * @notice Returns the current fee handler  */ function getFeeHandler() public view override returns (address) {     return currentAddresses[_FEE_HANDLER_KEY]; }  /**  * @notice Get the record for a position.  * @param payer Registered payer of the position.  * @param account Address holding the position.  * @param protocol Protocol where the position is held.  */ function getPosition(     address payer,     bytes32 account,     bytes32 protocol ) public view override returns (Record memory) {     return _positions[payer][account][protocol]; }  /**  * @notice Check whether a token is usable as a deposit token.  * @param token Address of token to check.  * @return True if token is usable as a deposit token for this action.  */ function isUsable(address token) public view override returns (bool) {     return _usableTokens.contains(token); }  function _updateTopUpHandler(     bytes32 protocol,     address oldHandler,     address newHandler ) internal {     if (newHandler == address(0)) {         _supportedProtocols.remove(protocol);     } else if (oldHandler == address(0)) {         _supportedProtocols.add(protocol);     } }  /**  * @dev Pays fees to the feeHandler  * @param payer The account who's position the fees are charged on  * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)  * @param feeAmount The amount in tokens to pay as fees  * @param depositToken The LpToken used to pay the fees  */ function _payFees(     address payer,     address beneficiary,     uint256 feeAmount,     address depositToken ) internal {     address feeHandler = getFeeHandler();     IERC20(depositToken).safeApprove(feeHandler, feeAmount);     IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken); }  /**  * @dev "Locks" an amount of tokens on behalf of the TopUpAction  * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.  * @param payer Owner of the funds to be locked  * @param token Token to lock  * @param lockAmount Minimum amount of `token` to lock  * @param depositAmount Amount of `token` that was deposited.  *                      If this is 0 then the staker vault allowance should be used.  *                      If this is greater than `requiredAmount` more tokens will be locked.  */ function _lockFunds(     address payer,     address token,     uint256 lockAmount,     uint256 depositAmount ) internal {     address stakerVaultAddress = addressProvider.getStakerVault(token);     TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount); }  function _removePosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     delete _positions[payer][account][protocol];     _removeUserPosition(payer, account, protocol);     if (_userPositions[payer].length == 0) {         _usersWithPositions.remove(payer);     }     emit Deregister(payer, account, protocol); }  function _removeUserPosition(     address payer,     bytes32 account,     bytes32 protocol ) internal {     RecordMeta[] storage positionsMeta = _userPositions[payer];     uint256 length = positionsMeta.length;     for (uint256 i = 0; i &lt; length; i++) {         RecordMeta storage positionMeta = positionsMeta[i];         if (positionMeta.account == account &amp;&amp; positionMeta.protocol == protocol) {             positionsMeta[i] = positionsMeta[length - 1];             positionsMeta.pop();             return;         }     } }  /**  * @dev Approves infinite spending for the given spender.  * @param token The token to approve for.  * @param spender The spender to approve.  */ function _approve(address token, address spender) internal {     if (IERC20(token).allowance(address(this), spender) &gt; 0) return;     IERC20(token).safeApprove(spender, type(uint256).max); }  /**  * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.  */ function _calcExchangeAmount(     address token,     address actionToken,     uint256 amount ) internal view returns (uint256) {     return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount); }  function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {     return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken); }  function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {     address handler = currentAddresses[_getProtocolKey(protocol)];     require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);     return handler; }  function _isSwappable(address depositToken, address toToken) internal view returns (bool) {     ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);     address underlying = pool.getUnderlying();     if (underlying == toToken) {         return true;     }     address swapperRegistry = addressProvider.getSwapperRegistry();     return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken); }  function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {     return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol)); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 19:22:42 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-29-08 19:22:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 19:22:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16377
completion_tokens: 1
total_tokens: 16378
cost: $0.049135


[2024-29-08 19:22:45 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "../../../interfaces/IGasBank.sol";
import "../../../interfaces/pool/ILiquidityPool.sol";
import "../../../interfaces/ISwapperRegistry.sol";
import "../../../interfaces/IController.sol";
import "../../../interfaces/IStakerVault.sol";
import "../../../interfaces/ISwapper.sol";
import "../../../interfaces/actions/topup/ITopUpHandler.sol";
import "../../../interfaces/actions/topup/ITopUpAction.sol";
import "../../../interfaces/actions/IActionFeeHandler.sol";

import "../../../libraries/AddressProviderHelpers.sol";
import "../../../libraries/Errors.sol";
import "../../../libraries/ScaledMath.sol";
import "../../../libraries/EnumerableExtensions.sol";

import "../../access/Authorization.sol";
import "../../utils/Preparable.sol";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being "too deep"
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = "ActionFee";
    bytes32 internal constant _FEE_HANDLER_KEY = "FeeHandler";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = "TopUpHandler";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = "EstimatedGasUsage";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = "MaxSwapperSlippage";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                "topUp(bytes32,address,uint256,bytes)",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new "balance" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev "Locks" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}
.]

###

[2024-29-08 19:22:45 INFO] **[Seminar Conclusion]**:

 ###

[2024-29-08 19:22:45 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=129918

**num_completion_tokens**=3166

**num_total_tokens**=133084

**duration**=75.00s

ChatDev Starts (20240829192130)

ChatDev Ends (20240829192245)



