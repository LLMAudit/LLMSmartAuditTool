[2024-29-08 22:49:35 INFO] **[Preprocessing]**

**ChatDev Starts** (20240829224935)

**Timestamp**: 20240829224935

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}


**project_name**: RealWorld_BA_113_NFTPairWithOracle

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_113_NFTPairWithOracle_RealWord_20240829224935.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-29-08 22:49:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | ( / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:49:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:49:35 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-29-08 22:49:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:49:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16986
completion_tokens: 1
total_tokens: 16987
cost: $-1.000000


[2024-29-08 22:49:38 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Let's

[2024-29-08 22:49:39 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: UNLICENSED\n// Private Pool (NFT collateral)\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | ( / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n    function asset() external view returns (IERC20);\n    function masterContract() external view returns (address);\n    function bentoBox() external view returns (IBentoBoxV1);\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n    // MasterContract variables\n    address public feeTo;\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n        emit LogLend(lender, tokenId);\n    }\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n    /// @notice Request and immediately borrow from a pre-committed lender\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n        uint128 principal = loanParams.valuation;\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n        emit LogRepay(from, tokenId);\n    }\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n        emit LogWithdrawFees(to, _share);\n    }\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED\n// Private Pool (NFT collateral)\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\___  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | (__ / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n    function asset() external view returns (IERC20);\n    function masterContract() external view returns (address);\n    function bentoBox() external view returns (IBentoBoxV1);\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n    // MasterContract variables\n    address public feeTo;\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n        emit LogLend(lender, tokenId);\n    }\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n    /// @notice Request and immediately borrow from a pre-committed lender\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n        uint128 principal = loanParams.valuation;\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n        emit LogRepay(from, tokenId);\n    }\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n        emit LogWithdrawFees(to, _share);\n    }\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:49:39 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:49:39 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED
// Private Pool (NFT collateral)
//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|
// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto
// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";
struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}
struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}
interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);
    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}
interface INFTPair {
    function collateral() external view returns (IERC721);
    function asset() external view returns (IERC20);
    function masterContract() external view returns (address);
    function bentoBox() external view returns (IBentoBoxV1);
    function removeCollateral(uint256 tokenId, address to) external;
}
/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;
    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);
    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;
    // MasterContract variables
    address public feeTo;
    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;
    // A note on terminology:
    // "Shares" are BentoBox shares.
    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;
    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;
    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;
    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;
    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;
    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;
    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }
    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }
    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }
    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;
        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }
    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }
    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");
            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }
    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];
        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );
        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }
        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;
        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;
        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;
        emit LogLend(lender, tokenId);
    }
    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }
    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):
    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;
    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;
    /// @notice Request and immediately borrow from a pre-committed lender
    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }
    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }
    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;
        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }
        if (interest >= 2**128) {
            revert();
        }
    }
    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );
        uint128 principal = loanParams.valuation;
        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;
        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);
        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];
        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);
        emit LogRepay(from, tokenId);
    }
    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;
    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;
    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;
    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;
    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;
    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;
    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }
    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }
    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }
    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );
        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }
        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");
        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }
    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);
                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }
    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();
        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }
        emit LogWithdrawFees(to, _share);
    }
    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED
// Private Pool (NFT collateral)
//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|
// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto
// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";
struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}
struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}
interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);
    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}
interface INFTPair {
    function collateral() external view returns (IERC721);
    function asset() external view returns (IERC20);
    function masterContract() external view returns (address);
    function bentoBox() external view returns (IBentoBoxV1);
    function removeCollateral(uint256 tokenId, address to) external;
}
/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;
    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);
    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;
    // MasterContract variables
    address public feeTo;
    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;
    // A note on terminology:
    // "Shares" are BentoBox shares.
    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;
    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;
    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;
    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;
    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;
    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;
    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }
    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }
    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }
    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;
        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }
    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }
    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");
            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }
    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];
        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );
        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }
        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;
        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;
        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;
        emit LogLend(lender, tokenId);
    }
    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }
    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):
    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;
    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;
    /// @notice Request and immediately borrow from a pre-committed lender
    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }
    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }
    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;
        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }
        if (interest >= 2**128) {
            revert();
        }
    }
    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );
        uint128 principal = loanParams.valuation;
        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;
        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);
        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];
        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);
        emit LogRepay(from, tokenId);
    }
    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;
    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;
    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;
    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;
    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;
    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;
    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }
    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }
    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }
    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );
        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }
        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");
        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }
    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);
                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }
    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();
        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }
        emit LogWithdrawFees(to, _share);
    }
    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-29-08 22:49:44 INFO] Retrying request to /chat/completions in 0.914621 seconds
[2024-29-08 22:49:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:49:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25534
completion_tokens: 1
total_tokens: 25535
cost: $-1.000000


[2024-29-08 22:49:49 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Security

[2024-29-08 22:49:49 INFO] **[Seminar Conclusion]**:

 Security

[2024-29-08 22:49:49 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-29-08 22:49:49 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-29-08 22:49:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | ( / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:49:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:49:49 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-29-08 22:49:52 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:49:52 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16977
completion_tokens: 1
total_tokens: 16978
cost: $-1.000000


[2024-29-08 22:49:52 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

###

[2024-29-08 22:49:52 INFO] **[Seminar Conclusion]**:

 ###

[2024-29-08 22:49:52 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-29-08 22:49:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:49:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:49:52 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-29-08 22:50:03 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:50:03 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8548
completion_tokens: 683
total_tokens: 9231
cost: $-1.000000


[2024-29-08 22:50:03 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Based on the provided smart contract code for the `NFTPairWithOracle` contract, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Risk**: 
   - The contract allows external calls to arbitrary contracts through the `_call` function. This could potentially lead to reentrancy attacks if the called contract is malicious or not properly audited.

2. **Lack of Input Validation**:
   - The contract does not sufficiently validate inputs in several functions, such as `updateLoanParams`, `lend`, and `requestLoan`. This could allow for unexpected behavior or exploitation if invalid parameters are passed.

3. **Oracle Dependency**:
   - The contract relies on external oracles (e.g., `INFTOracle`) for price feeds. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses or allow for exploitation of the loan terms.

4. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.12 has built-in overflow checks, there are still areas where arithmetic operations could lead to unexpected results if not handled properly, especially in the `calculateInterest` function.

5. **Improper Access Control**:
   - Functions like `removeCollateral` and `updateLoanParams` rely on the status of the loan and the caller's role but do not enforce strict access control checks. This could allow unauthorized users to manipulate loans or collateral.

6. **Gas Limit Issues**:
   - The `cook` function allows for multiple actions to be executed in a single transaction. If any of these actions consume too much gas, it could lead to transaction failures, potentially locking funds or collateral.

7. **Signature Replay Attacks**:
   - The contract uses signatures for lending and borrowing requests but does not implement nonce management effectively to prevent replay attacks across different contexts.

8. **Protocol Fee Handling**:
   - The handling of protocol fees and their distribution could be exploited if not properly managed, especially if the fee structure changes or if there are bugs in the fee calculation logic.

### Comprehensive Analysis Report

The `NFTPairWithOracle` contract presents several security vulnerabilities that could be exploited by malicious actors. The reliance on external oracles introduces a significant risk, as any compromise of the oracle could lead to incorrect valuations and financial losses. Additionally, the potential for reentrancy attacks due to external calls and the lack of strict input validation in critical functions could allow for unexpected behaviors or exploits.

Access control mechanisms are not sufficiently robust, which could enable unauthorized users to manipulate loan parameters or collateral. Furthermore, while Solidity's built-in checks mitigate overflow risks, the complexity of calculations in functions like `calculateInterest` necessitates careful scrutiny to ensure that no unexpected results occur.

The contract's design allows for multiple actions to be executed in a single transaction, which, while efficient, raises concerns about gas limits and transaction failures. Lastly, the handling of signatures for lending and borrowing requests needs to be fortified against replay attacks to ensure that signatures cannot be reused maliciously.

In conclusion, while the contract implements a complex lending mechanism for NFTs, it requires significant improvements in security practices, including enhanced access controls, robust input validation, and careful management of external dependencies. A thorough audit and testing phase should be conducted to address these vulnerabilities before deployment to ensure the safety and integrity of user funds.

[2024-29-08 22:50:03 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NFTPairWithOracle` contract, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Risk**: 
   - The contract allows external calls to arbitrary contracts through the `_call` function. This could potentially lead to reentrancy attacks if the called contract is malicious or not properly audited.

2. **Lack of Input Validation**:
   - The contract does not sufficiently validate inputs in several functions, such as `updateLoanParams`, `lend`, and `requestLoan`. This could allow for unexpected behavior or exploitation if invalid parameters are passed.

3. **Oracle Dependency**:
   - The contract relies on external oracles (e.g., `INFTOracle`) for price feeds. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses or allow for exploitation of the loan terms.

4. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.12 has built-in overflow checks, there are still areas where arithmetic operations could lead to unexpected results if not handled properly, especially in the `calculateInterest` function.

5. **Improper Access Control**:
   - Functions like `removeCollateral` and `updateLoanParams` rely on the status of the loan and the caller's role but do not enforce strict access control checks. This could allow unauthorized users to manipulate loans or collateral.

6. **Gas Limit Issues**:
   - The `cook` function allows for multiple actions to be executed in a single transaction. If any of these actions consume too much gas, it could lead to transaction failures, potentially locking funds or collateral.

7. **Signature Replay Attacks**:
   - The contract uses signatures for lending and borrowing requests but does not implement nonce management effectively to prevent replay attacks across different contexts.

8. **Protocol Fee Handling**:
   - The handling of protocol fees and their distribution could be exploited if not properly managed, especially if the fee structure changes or if there are bugs in the fee calculation logic.

### Comprehensive Analysis Report

The `NFTPairWithOracle` contract presents several security vulnerabilities that could be exploited by malicious actors. The reliance on external oracles introduces a significant risk, as any compromise of the oracle could lead to incorrect valuations and financial losses. Additionally, the potential for reentrancy attacks due to external calls and the lack of strict input validation in critical functions could allow for unexpected behaviors or exploits.

Access control mechanisms are not sufficiently robust, which could enable unauthorized users to manipulate loan parameters or collateral. Furthermore, while Solidity's built-in checks mitigate overflow risks, the complexity of calculations in functions like `calculateInterest` necessitates careful scrutiny to ensure that no unexpected results occur.

The contract's design allows for multiple actions to be executed in a single transaction, which, while efficient, raises concerns about gas limits and transaction failures. Lastly, the handling of signatures for lending and borrowing requests needs to be fortified against replay attacks to ensure that signatures cannot be reused maliciously.

In conclusion, while the contract implements a complex lending mechanism for NFTs, it requires significant improvements in security practices, including enhanced access controls, robust input validation, and careful management of external dependencies. A thorough audit and testing phase should be conducted to address these vulnerabilities before deployment to ensure the safety and integrity of user funds.

[2024-29-08 22:50:03 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-29-08 22:50:03 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | ( / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:50:03 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:50:03 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-29-08 22:50:06 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:50:06 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16977
completion_tokens: 1
total_tokens: 16978
cost: $-1.000000


[2024-29-08 22:50:06 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

###

[2024-29-08 22:50:06 INFO] **[Seminar Conclusion]**:

 ###

[2024-29-08 22:50:06 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-29-08 22:50:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:50:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:50:06 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-29-08 22:50:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:50:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8548
completion_tokens: 738
total_tokens: 9286
cost: $-1.000000


[2024-29-08 22:50:18 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Based on the provided smart contract code for the `NFTPairWithOracle` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to arbitrary contracts (except BentoBox) without proper checks, which could lead to reentrancy attacks. Functions like `repay`, `removeCollateral`, and `_call` could be exploited if an external contract calls back into the `NFTPairWithOracle` contract.

2. **Lack of Input Validation**:
   - Functions such as `updateLoanParams` and `lend` do not sufficiently validate the input parameters. For instance, there is no check to ensure that the `annualInterestBPS`, `ltvBPS`, and `valuation` are within acceptable ranges before processing.

3. **Oracle Manipulation Risk**:
   - The contract relies on external oracles (e.g., `INFTOracle`) for price feeds. If the oracle is compromised or provides incorrect data, it could lead to improper valuations and potential losses for lenders or borrowers.

4. **Insufficient Access Control**:
   - The contract does not enforce strict access control on certain functions. For example, the `removeCollateral` function allows the lender to seize collateral under specific conditions, which could be exploited if the lender is malicious or colludes with the borrower.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.12 has built-in overflow checks, there are still areas where unchecked arithmetic could lead to unexpected behavior, especially in calculations involving interest and fees.

6. **Signature Replay Attacks**:
   - The contract uses signatures for certain operations (e.g., `requestAndBorrow`, `takeCollateralAndLend`). If the nonce management is not handled correctly, it could lead to replay attacks where a valid signature is reused maliciously.

7. **Unrestricted Fee Withdrawal**:
   - The `withdrawFees` function allows the owner to withdraw accumulated fees without any restrictions or limits, which could be exploited if the owner account is compromised.

### Comprehensive Analysis Report

The `NFTPairWithOracle` contract presents several security vulnerabilities that could be exploited by malicious actors. The most pressing concerns include the potential for reentrancy attacks due to external calls, reliance on external oracles that may be manipulated, and insufficient input validation that could lead to erroneous contract behavior.

To mitigate these risks, the following recommendations are proposed:

- **Implement Reentrancy Guards**: Use the `ReentrancyGuard` pattern to prevent reentrant calls to critical functions.
- **Enhance Input Validation**: Ensure that all input parameters are validated against expected ranges and conditions before processing.
- **Secure Oracle Usage**: Consider implementing a fallback mechanism or multiple oracles to reduce reliance on a single source of truth.
- **Strengthen Access Control**: Use role-based access control to restrict sensitive operations to authorized users only.
- **Review Arithmetic Operations**: Although Solidity 0.6.12 provides overflow checks, ensure that all arithmetic operations are carefully reviewed to avoid unexpected behavior.
- **Nonce Management**: Implement a robust nonce management system to prevent replay attacks on signature-based functions.
- **Limit Fee Withdrawals**: Introduce limits or multi-signature requirements for fee withdrawals to enhance security against potential exploits.

In conclusion, while the `NFTPairWithOracle` contract has a well-defined purpose in facilitating NFT-backed loans, it requires significant security improvements to safeguard against potential vulnerabilities. A thorough audit and implementation of the recommended measures are essential to enhance the contract's security posture.

[2024-29-08 22:50:18 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NFTPairWithOracle` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to arbitrary contracts (except BentoBox) without proper checks, which could lead to reentrancy attacks. Functions like `repay`, `removeCollateral`, and `_call` could be exploited if an external contract calls back into the `NFTPairWithOracle` contract.

2. **Lack of Input Validation**:
   - Functions such as `updateLoanParams` and `lend` do not sufficiently validate the input parameters. For instance, there is no check to ensure that the `annualInterestBPS`, `ltvBPS`, and `valuation` are within acceptable ranges before processing.

3. **Oracle Manipulation Risk**:
   - The contract relies on external oracles (e.g., `INFTOracle`) for price feeds. If the oracle is compromised or provides incorrect data, it could lead to improper valuations and potential losses for lenders or borrowers.

4. **Insufficient Access Control**:
   - The contract does not enforce strict access control on certain functions. For example, the `removeCollateral` function allows the lender to seize collateral under specific conditions, which could be exploited if the lender is malicious or colludes with the borrower.

5. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.12 has built-in overflow checks, there are still areas where unchecked arithmetic could lead to unexpected behavior, especially in calculations involving interest and fees.

6. **Signature Replay Attacks**:
   - The contract uses signatures for certain operations (e.g., `requestAndBorrow`, `takeCollateralAndLend`). If the nonce management is not handled correctly, it could lead to replay attacks where a valid signature is reused maliciously.

7. **Unrestricted Fee Withdrawal**:
   - The `withdrawFees` function allows the owner to withdraw accumulated fees without any restrictions or limits, which could be exploited if the owner account is compromised.

### Comprehensive Analysis Report

The `NFTPairWithOracle` contract presents several security vulnerabilities that could be exploited by malicious actors. The most pressing concerns include the potential for reentrancy attacks due to external calls, reliance on external oracles that may be manipulated, and insufficient input validation that could lead to erroneous contract behavior.

To mitigate these risks, the following recommendations are proposed:

- **Implement Reentrancy Guards**: Use the `ReentrancyGuard` pattern to prevent reentrant calls to critical functions.
- **Enhance Input Validation**: Ensure that all input parameters are validated against expected ranges and conditions before processing.
- **Secure Oracle Usage**: Consider implementing a fallback mechanism or multiple oracles to reduce reliance on a single source of truth.
- **Strengthen Access Control**: Use role-based access control to restrict sensitive operations to authorized users only.
- **Review Arithmetic Operations**: Although Solidity 0.6.12 provides overflow checks, ensure that all arithmetic operations are carefully reviewed to avoid unexpected behavior.
- **Nonce Management**: Implement a robust nonce management system to prevent replay attacks on signature-based functions.
- **Limit Fee Withdrawals**: Introduce limits or multi-signature requirements for fee withdrawals to enhance security against potential exploits.

In conclusion, while the `NFTPairWithOracle` contract has a well-defined purpose in facilitating NFT-backed loans, it requires significant security improvements to safeguard against potential vulnerabilities. A thorough audit and implementation of the recommended measures are essential to enhance the contract's security posture.

[2024-29-08 22:50:18 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-29-08 22:50:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | ( / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:50:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:50:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-29-08 22:50:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:50:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16977
completion_tokens: 1
total_tokens: 16978
cost: $-1.000000


[2024-29-08 22:50:21 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

###

[2024-29-08 22:50:21 INFO] **[Seminar Conclusion]**:

 ###

[2024-29-08 22:50:21 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-29-08 22:50:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-29-08 22:50:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:50:21 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-29-08 22:50:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-29-08 22:50:34 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8548
completion_tokens: 771
total_tokens: 9319
cost: $-1.000000


[2024-29-08 22:50:34 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Based on the provided smart contract code for the `NFTPairWithOracle` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls (e.g., transferring NFTs or assets) without proper checks, which could lead to reentrancy attacks. For instance, the `removeCollateral` and `repay` functions could be exploited if an attacker re-enters the contract during these operations.

2. **Lack of Input Validation**:
   - The contract does not sufficiently validate inputs in functions like `updateLoanParams`, `lend`, and `requestLoan`. This could allow for invalid or malicious parameters to be processed, leading to unintended behavior.

3. **Signature Replay Attacks**:
   - The contract uses nonces for signature validation but does not enforce unique nonces across all users. This could lead to replay attacks where a valid signature could be reused maliciously.

4. **Oracle Dependency Risks**:
   - The contract relies on external oracles for price feeds (e.g., `INFTOracle`). If the oracle is compromised or provides incorrect data, it could lead to significant financial losses, especially during liquidation scenarios.

5. **Gas Limit and Block Size Issues**:
   - The `cook` function allows for multiple actions to be executed in a single transaction. If the cumulative gas cost exceeds the block gas limit, the transaction will fail, which could be exploited to deny service.

6. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.12 has built-in overflow checks, the use of external libraries (like `BoringMath`) may introduce risks if not properly audited. Care should be taken to ensure that all mathematical operations are safe.

7. **Access Control Issues**:
   - Functions like `setFeeTo` and `withdrawFees` can be called by the contract owner, but there is no mechanism to ensure that the owner is not compromised. This could lead to unauthorized access to funds.

8. **Improper Handling of Collateral**:
   - The contract allows for the removal of collateral even when loans are outstanding, which could lead to situations where lenders are left without recourse if the borrower defaults.

### Comprehensive Analysis Report

The `NFTPairWithOracle` contract presents several security vulnerabilities that could be exploited by malicious actors. The most pressing issues include the potential for reentrancy attacks, which could allow attackers to manipulate the state of the contract during critical operations. Additionally, the reliance on external oracles introduces risks associated with data integrity and availability.

The lack of stringent input validation and the possibility of signature replay attacks further compound the security risks. Access control mechanisms need to be strengthened to prevent unauthorized actions by compromised accounts.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Use the Checks-Effects-Interactions pattern and consider implementing reentrancy guards on critical functions.
- **Input Validation**: Ensure all inputs are validated against expected ranges and conditions.
- **Nonce Management**: Implement a more robust nonce management system to prevent replay attacks.
- **Oracle Fail-safes**: Introduce fallback mechanisms or alternative data sources to handle oracle failures or discrepancies.
- **Gas Limit Handling**: Consider breaking down complex operations into smaller, manageable transactions to avoid gas limit issues.
- **Access Control Enhancements**: Implement multi-signature wallets or time-lock mechanisms for sensitive functions to enhance security.
- **Collateral Management**: Review and revise the logic surrounding collateral removal to ensure that lenders are adequately protected.

By addressing these vulnerabilities, the contract can be made more secure and resilient against potential attacks, ultimately protecting the assets and interests of all participants in the lending ecosystem.

[2024-29-08 22:50:34 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `NFTPairWithOracle` contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls (e.g., transferring NFTs or assets) without proper checks, which could lead to reentrancy attacks. For instance, the `removeCollateral` and `repay` functions could be exploited if an attacker re-enters the contract during these operations.

2. **Lack of Input Validation**:
   - The contract does not sufficiently validate inputs in functions like `updateLoanParams`, `lend`, and `requestLoan`. This could allow for invalid or malicious parameters to be processed, leading to unintended behavior.

3. **Signature Replay Attacks**:
   - The contract uses nonces for signature validation but does not enforce unique nonces across all users. This could lead to replay attacks where a valid signature could be reused maliciously.

4. **Oracle Dependency Risks**:
   - The contract relies on external oracles for price feeds (e.g., `INFTOracle`). If the oracle is compromised or provides incorrect data, it could lead to significant financial losses, especially during liquidation scenarios.

5. **Gas Limit and Block Size Issues**:
   - The `cook` function allows for multiple actions to be executed in a single transaction. If the cumulative gas cost exceeds the block gas limit, the transaction will fail, which could be exploited to deny service.

6. **Potential for Integer Overflow/Underflow**:
   - Although Solidity 0.6.12 has built-in overflow checks, the use of external libraries (like `BoringMath`) may introduce risks if not properly audited. Care should be taken to ensure that all mathematical operations are safe.

7. **Access Control Issues**:
   - Functions like `setFeeTo` and `withdrawFees` can be called by the contract owner, but there is no mechanism to ensure that the owner is not compromised. This could lead to unauthorized access to funds.

8. **Improper Handling of Collateral**:
   - The contract allows for the removal of collateral even when loans are outstanding, which could lead to situations where lenders are left without recourse if the borrower defaults.

### Comprehensive Analysis Report

The `NFTPairWithOracle` contract presents several security vulnerabilities that could be exploited by malicious actors. The most pressing issues include the potential for reentrancy attacks, which could allow attackers to manipulate the state of the contract during critical operations. Additionally, the reliance on external oracles introduces risks associated with data integrity and availability.

The lack of stringent input validation and the possibility of signature replay attacks further compound the security risks. Access control mechanisms need to be strengthened to prevent unauthorized actions by compromised accounts.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Use the Checks-Effects-Interactions pattern and consider implementing reentrancy guards on critical functions.
- **Input Validation**: Ensure all inputs are validated against expected ranges and conditions.
- **Nonce Management**: Implement a more robust nonce management system to prevent replay attacks.
- **Oracle Fail-safes**: Introduce fallback mechanisms or alternative data sources to handle oracle failures or discrepancies.
- **Gas Limit Handling**: Consider breaking down complex operations into smaller, manageable transactions to avoid gas limit issues.
- **Access Control Enhancements**: Implement multi-signature wallets or time-lock mechanisms for sensitive functions to enhance security.
- **Collateral Management**: Review and revise the logic surrounding collateral removal to ensure that lenders are adequately protected.

By addressing these vulnerabilities, the contract can be made more secure and resilient against potential attacks, ultimately protecting the assets and interests of all participants in the lending ecosystem.

[2024-29-08 22:50:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\      )    (   )\  )\ )  (\n//  ((()  ( /(   ))\ (()(()/(  )(    (    (\n//  )\  )()) /(() _   (())(()\   )\   )\ )\n// ((/ |(() ())( | |  | |  (() (() (/(\n//  | ( / || || || |/ _ | | \'_|/ _ \| \' \))\n//   \|\,| \,|||\__,| |_|  \/||||\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";\nimport "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";\nimport "@boringcrypto/boring-solidity/contracts/Domain.sol";\nimport "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";\nimport "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";\nimport "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";\nimport "./interfaces/IERC721.sol";\nimport "./interfaces/INFTOracle.sol";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don\'t trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // "Shares" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 =&gt; TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // calculateIntest.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns "second-order" interest-on-interest, which\n    // itself earns "third-order" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \           x^k                \              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why "at least"? There are also rounding errors. See\n    // calculateInterest for more detail.\n    // The factorial in the denominator "wins"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the "true" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in "total"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address =&gt; uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via init.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), "NFTPair: already initialized");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), "NFTPair: bad pair");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, "NFTPair: not the lender");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration &gt;= cur.duration &amp;&amp;\n                    params.valuation &lt;= cur.valuation &amp;&amp;\n                    params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;\n                    params.ltvBPS &lt;= cur.ltvBPS,\n                "NFTPair: worse params"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert("NFTPair: no collateral");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes tokenId as collateral and transfers it to to.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, "NFTPair: not the borrower");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, "NFTPair: not the lender");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with skim set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as accepted.\n        require(\n            params.valuation == accepted.valuation &amp;&amp;\n                params.duration &lt;= accepted.duration &amp;&amp;\n                params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;\n                params.ltvBPS &gt;= accepted.ltvBPS,\n            "NFTPair: bad params"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                "NFTPair: skim too much"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS &lt;= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");\n        } else {\n            require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner\'s method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n &gt; 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \           principal * (t * aprBPS)^k        \\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the "theoretical" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term{k-1} * ------------                          ()\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From () we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M &gt;= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // &lt;- Only overflow check we need\n        }\n\n        if (interest &gt;= 2128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,\n            "NFTPair: loan expired"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (value1 or value2) depending on inNum.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into bentoBox.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the bentoBox.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to bentoBox or collateral are not allowed for security reasons.\n    /// This also means that calls made from this contract shall not be trusted.\n    function call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 &amp;&amp; !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 &amp;&amp; useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can\'t call");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, "NFTPair: call failed");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION declarations).\n    /// @param values A one-to-one mapped array to actions. ETH amounts to send along with the actions.\n    /// Only applicable to ACTION_CALL, ACTION_BENTO_DEPOSIT.\n    /// @param datas A one-to-one mapped array to actions. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i &lt; actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share &gt; 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-29-08 22:50:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED // Private Pool (NFT collateral) //    (                (   ( //    )\      )    (   )\  )\ )  ( //  ((()  ( /(   ))\ (()(()/(  )(    (    ( //  )_  )()) /(() _   ((_))(()\   )\   )\ ) // ((/ |(() ())( | |  | |  (() (() (/( //  | ( / || || || |/ _ | | '|/ _ \| ' )) //   _|_,| _,|||_,| ||  ___/|||_| // Copyright (c) 2021 BoringCrypto - All rights reserved // Twitter: @Boring_Crypto // Special thanks to: // @0xKeno - for all his invaluable contributions // @burger_crypto - for the idea of trying to let the LPs benefit from liquidations pragma solidity 0.6.12; pragma experimental ABIEncoderV2; import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"; import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"; import "@boringcrypto/boring-solidity/contracts/Domain.sol"; import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"; import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"; import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"; import "./interfaces/IERC721.sol"; import "./interfaces/INFTOracle.sol"; struct TokenLoanParams {     uint128 valuation; // How much will you get? OK to owe until expiration.     uint64 duration; // Length of loan in seconds     uint16 annualInterestBPS; // Variable cost of taking out the loan     uint16 ltvBPS; // Required to avoid liquidation     INFTOracle oracle; // oracle used } struct SignatureParams {     uint256 deadline;     uint8 v;     bytes32 r;     bytes32 s; } interface ILendingClub {     // Per token settings.     function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool); function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);  } interface INFTPair {     function collateral() external view returns (IERC721); function asset() external view returns (IERC20);  function masterContract() external view returns (address);  function bentoBox() external view returns (IBentoBoxV1);  function removeCollateral(uint256 tokenId, address to) external;  } /// @title NFTPairWithOracle /// @dev This contract allows contract calls to any contract (except BentoBox) /// from arbitrary callers thus, don't trust calls from this contract in any circumstances. contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {     using BoringMath for uint256;     using BoringMath128 for uint128;     using RebaseLibrary for Rebase;     using BoringERC20 for IERC20; event LogRequestLoan(     address indexed borrower,     uint256 indexed tokenId,     uint128 valuation,     uint64 duration,     uint16 annualInterestBPS,     uint16 ltvBPS ); event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS); // This automatically clears the associated loan, if any event LogRemoveCollateral(uint256 indexed tokenId, address recipient); // Details are in the loan request event LogLend(address indexed lender, uint256 indexed tokenId); event LogRepay(address indexed from, uint256 indexed tokenId); event LogFeeTo(address indexed newFeeTo); event LogWithdrawFees(address indexed feeTo, uint256 feeShare);  // Immutables (for MasterContract and all clones) IBentoBoxV1 public immutable bentoBox; NFTPairWithOracle public immutable masterContract;  // MasterContract variables address public feeTo;  // Per clone variables // Clone init settings IERC721 public collateral; IERC20 public asset;  // A note on terminology: // "Shares" are BentoBox shares.  // Track assets we own. Used to allow skimming the excesss. uint256 public feesEarnedShare;  // Per token settings. mapping(uint256 =&gt; TokenLoanParams) public tokenLoanParams;  uint8 private constant LOAN_INITIAL = 0; uint8 private constant LOAN_REQUESTED = 1; uint8 private constant LOAN_OUTSTANDING = 2; struct TokenLoan {     address borrower;     address lender;     uint64 startTime;     uint8 status; } mapping(uint256 =&gt; TokenLoan) public tokenLoan;  // Do not go over 100% on either of these.. uint256 private constant PROTOCOL_FEE_BPS = 1000; uint256 private constant OPEN_FEE_BPS = 100; uint256 private constant BPS = 10_000; uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;  // Highest order term in the Maclaurin series for exp used by // `calculateIntest`. // Intuitive interpretation: interest continuously accrues on the principal. // That interest, in turn, earns "second-order" interest-on-interest, which // itself earns "third-order" interest, etc. This constant determines how // far we take this until we stop counting. // // The error, in terms of the interest rate, is at least // //            ----- n                        ----- Infinity //             \           x^k                \              x^k //      e^x -   )          ---   , which is    )             --- , //             /            k!                /               k! //            ----- k = 1       k            ----- k = n + 1 // // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of // interest that is owed at rate r over time t. It makes no difference if // this is, say, 5%/year for 10 years, or 50% in one year; the calculation // is the same. Why "at least"? There are also rounding errors. See // `calculateInterest` for more detail. // The factorial in the denominator "wins"; for all reasonable (and quite // a few unreasonable) interest rates, the lower-order terms contribute the // most to the total. The following table lists some of the calculated // approximations for different values of n, along with the "true" result: // // Total:         10%    20%    50%    100%    200%      500%       1000% // ----------------------------------------------------------------------- // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0% // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0% // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7% // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3% // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7% // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6% // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3% // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1% // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3% // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5% // // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6% // // For instance, calculating the compounding effects of 200% in "total" // interest to the sixth order results in 635.6%, whereas the true result // is 638.9%. // At 500% that difference is a little more dramatic, but it is still in // the same ballpark -- and of little practical consequence unless the // collateral can be expected to go up more than 112 times in value. // Still, for volatile tokens, or an asset that is somehow known to be very // inflationary, use a different number. // Zero (no interest at all) is ignored and treated as one (linear only). uint8 private constant COMPOUND_INTEREST_TERMS = 6;  // For signed lend / borrow requests: mapping(address =&gt; uint256) public nonces;  /// @notice The constructor is only used for the initial master contract. /// @notice Subsequent clones are initialised via `init`. constructor(IBentoBoxV1 bentoBox_) public {     bentoBox = bentoBox_;     masterContract = this; }  /// @notice De facto constructor for clone contracts function init(bytes calldata data) public payable override {     require(address(collateral) == address(0), "NFTPair: already initialized");     (collateral, asset) = abi.decode(data, (IERC721, IERC20));     require(address(collateral) != address(0), "NFTPair: bad pair"); }  function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_OUTSTANDING) {         // The lender can change terms so long as the changes are strictly         // the same or better for the borrower:         require(msg.sender == loan.lender, "NFTPair: not the lender");         TokenLoanParams memory cur = tokenLoanParams[tokenId];         require(             params.duration &gt;= cur.duration &amp;&amp;                 params.valuation &lt;= cur.valuation &amp;&amp;                 params.annualInterestBPS &lt;= cur.annualInterestBPS &amp;&amp;                 params.ltvBPS &lt;= cur.ltvBPS,             "NFTPair: worse params"         );     } else if (loan.status == LOAN_REQUESTED) {         // The borrower has already deposited the collateral and can         // change whatever they like         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else {         // The loan has not been taken out yet; the borrower needs to         // provide collateral.         revert("NFTPair: no collateral");     }     tokenLoanParams[tokenId] = params;     emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  function _requestLoan(     address collateralProvider,     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) private {     // Edge case: valuation can be zero. That effectively gifts the NFT and     // is therefore a bad idea, but does not break the contract.     require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");     if (skim) {         require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");     } else {         collateral.transferFrom(collateralProvider, address(this), tokenId);     }     TokenLoan memory loan;     loan.borrower = to;     loan.status = LOAN_REQUESTED;     tokenLoan[tokenId] = loan;     tokenLoanParams[tokenId] = params;      emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS); }  /// @notice Deposit an NFT as collateral and request a loan against it /// @param tokenId ID of the NFT /// @param to Address to receive the loan, or option to withdraw collateral /// @param params Loan conditions on offer /// @param skim True if the token has already been transfered function requestLoan(     uint256 tokenId,     TokenLoanParams memory params,     address to,     bool skim ) public {     _requestLoan(msg.sender, tokenId, params, to, skim); }  /// @notice Removes `tokenId` as collateral and transfers it to `to`. /// @notice This destroys the loan. /// @param tokenId The token /// @param to The receiver of the token. function removeCollateral(uint256 tokenId, address to) public {     TokenLoan memory loan = tokenLoan[tokenId];     if (loan.status == LOAN_REQUESTED) {         // We are withdrawing collateral that is not in use:         require(msg.sender == loan.borrower, "NFTPair: not the borrower");     } else if (loan.status == LOAN_OUTSTANDING) {         // We are seizing collateral towards the lender. The loan has to be         // expired and not paid off, or underwater and not paid off:         require(to == loan.lender, "NFTPair: not the lender");          if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration &gt; block.timestamp) {             TokenLoanParams memory loanParams = tokenLoanParams[tokenId];             // No underflow: loan.startTime is only ever set to a block timestamp             // Cast is safe: if this overflows, then all loans have expired anyway             uint256 interest = calculateInterest(                 loanParams.valuation,                 uint64(block.timestamp - loan.startTime),                 loanParams.annualInterestBPS             ).to128();             uint256 amount = loanParams.valuation + interest;             (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);             require(rate.mul(loanParams.ltvBPS) / BPS &lt; amount, "NFT is still valued");         }     }     // If there somehow is collateral but no accompanying loan, then anyone     // can claim it by first requesting a loan with `skim` set to true, and     // then withdrawing. So we might as well allow it here..     delete tokenLoan[tokenId];     collateral.transferFrom(address(this), to, tokenId);     emit LogRemoveCollateral(tokenId, to); }  // Assumes the lender has agreed to the loan. function _lend(     address lender,     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) internal {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_REQUESTED, "NFTPair: not available");     TokenLoanParams memory params = tokenLoanParams[tokenId];      // Valuation has to be an exact match, everything else must be at least     // as good for the lender as `accepted`.     require(         params.valuation == accepted.valuation &amp;&amp;             params.duration &lt;= accepted.duration &amp;&amp;             params.annualInterestBPS &gt;= accepted.annualInterestBPS &amp;&amp;             params.ltvBPS &gt;= accepted.ltvBPS,         "NFTPair: bad params"     );      if (params.oracle != INFTOracle(0)) {         (, uint256 rate) = params.oracle.get(address(this), tokenId);         require(rate.mul(uint256(params.ltvBPS)) / BPS &gt;= params.valuation, "Oracle: price too low.");     }      uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);     // No overflow: at most 128 + 16 bits (fits in BentoBox)     uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;     uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;      if (skim) {         require(             bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),             "NFTPair: skim too much"         );     } else {         bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);     }     // No underflow: follows from OPEN_FEE_BPS &lt;= BPS     uint256 borrowerShare = totalShare - openFeeShare;     bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);     // No overflow: addends (and result) must fit in BentoBox     feesEarnedShare += protocolFeeShare;      loan.lender = lender;     loan.status = LOAN_OUTSTANDING;     loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..     tokenLoan[tokenId] = loan;      emit LogLend(lender, tokenId); }  /// @notice Lends with the parameters specified by the borrower. /// @param tokenId ID of the token that will function as collateral /// @param accepted Loan parameters as the lender saw them, for security /// @param skim True if the funds have been transfered to the contract function lend(     uint256 tokenId,     TokenLoanParams memory accepted,     bool skim ) public {     _lend(msg.sender, tokenId, accepted, skim); }  // solhint-disable-next-line func-name-mixedcase function DOMAIN_SEPARATOR() external view returns (bytes32) {     return _domainSeparator(); }  // NOTE on signature hashes: the domain separator only guarantees that the // chain ID and master contract are a match, so we explicitly include the // clone address (and the asset/collateral addresses):  // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;  // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)") bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;  /// @notice Request and immediately borrow from a pre-committed lender  /// @notice Caller provides collateral; loan can go to a different address. /// @param tokenId ID of the token that will function as collateral /// @param lender Lender, whose BentoBox balance the funds will come from /// @param recipient Address to receive the loan. /// @param params Loan parameters requested, and signed by the lender /// @param skimCollateral True if the collateral has already been transfered /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature. function requestAndBorrow(     uint256 tokenId,     address lender,     address recipient,     TokenLoanParams memory params,     bool skimCollateral,     bool anyTokenId,     SignatureParams memory signature ) public {     if (signature.v == 0 &amp;&amp; signature.r == bytes32(0) &amp;&amp; signature.s == bytes32(0)) {         require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");     } else {         require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");         uint256 nonce = nonces[lender]++;         bytes32 dataHash = keccak256(             abi.encode(                 LEND_SIGNATURE_HASH,                 address(this),                 anyTokenId ? 0 : tokenId,                 anyTokenId,                 params.valuation,                 params.duration,                 params.annualInterestBPS,                 params.ltvBPS,                 params.oracle,                 nonce,                 signature.deadline             )         );         require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");     }     _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);     _lend(lender, tokenId, params, false); }  /// @notice Take collateral from a pre-commited borrower and lend against it /// @notice Collateral must come from the borrower, not a third party. /// @param tokenId ID of the token that will function as collateral /// @param borrower Address that provides collateral and receives the loan /// @param params Loan terms offered, and signed by the borrower /// @param skimFunds True if the funds have been transfered to the contract function takeCollateralAndLend(     uint256 tokenId,     address borrower,     TokenLoanParams memory params,     bool skimFunds,     SignatureParams memory signature ) public {     require(block.timestamp &lt;= signature.deadline, "NFTPair: signature expired");     uint256 nonce = nonces[borrower]++;     bytes32 dataHash = keccak256(         abi.encode(             BORROW_SIGNATURE_HASH,             address(this),             tokenId,             params.valuation,             params.duration,             params.annualInterestBPS,             params.ltvBPS,             params.oracle,             nonce,             signature.deadline         )     );     require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");     _requestLoan(borrower, tokenId, params, borrower, false);     _lend(msg.sender, tokenId, params, skimFunds); }  /// Approximates continuous compounding. Uses Horner's method to evaluate /// the truncated Maclaurin series for exp - 1, accumulating rounding /// errors along the way. The following is always guaranteed: /// ///   principal * time * apr &lt;= result &lt;= principal * (e^(time * apr) - 1), /// /// where time = t/YEAR, up to at most the rounding error obtained in /// calculating linear interest. /// /// If the theoretical result that we are approximating (the rightmost part /// of the above inquality) fits in 128 bits, then the function is /// guaranteed not to revert (unless n &gt; 250, which is way too high). /// If even the linear interest (leftmost part of the inequality) does not /// the function will revert. /// Otherwise, the function may revert, return a reasonable result, or /// return a very inaccurate result. Even then the above inequality is /// respected. function calculateInterest(     uint256 principal,     uint64 t,     uint16 aprBPS ) public pure returns (uint256 interest) {     // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)     //     // We calculate     //     //  ----- n                                       ----- n     //   \           principal * (t * aprBPS)^k        \     //    )          --------------------------   =:    )          term_k     //   /                k! * YEAR_BPS^k              /     //  ----- k = 1                                   ----- k = 1     //     // which approaches, but never exceeds the "theoretical" result,     //     //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1     //     // as n goes to infinity. We use the fact that     //     //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)     //      term_k = ---------------------------------------------     //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS     //     //                             t * aprBPS     //             = term_{k-1} * ------------                          (*)     //                            k * YEAR_BPS     //     // to calculate the terms one by one. The principal affords us the     // precision to carry out the division without resorting to fixed-point     // math. Any rounding error is downward, which we consider acceptable.     //     // Since all numbers involved are positive, each term is certainly     // bounded above by M. From (*) we see that any intermediate results     // are at most     //     //                      denom_k := k * YEAR_BPS.     //     // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,     // which proves that all calculations will certainly not overflow if M     // fits in 128 bits.     //     // If M does not fit, then the intermediate results for some term may     // eventually overflow, but this cannot happen at the first term, and     // neither can the total overflow because it uses checked math.     //     // This constitutes a guarantee of specified behavior when M &gt;= 2^128.     uint256 x = uint256(t) * aprBPS;     uint256 term_k = (principal * x) / YEAR_BPS;     uint256 denom_k = YEAR_BPS;      interest = term_k;     for (uint256 k = 2; k &lt;= COMPOUND_INTEREST_TERMS; k++) {         denom_k += YEAR_BPS;         term_k = (term_k * x) / denom_k;         interest = interest.add(term_k); // &lt;- Only overflow check we need     }      if (interest &gt;= 2**128) {         revert();     } }  function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {     TokenLoan memory loan = tokenLoan[tokenId];     require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");     TokenLoanParams memory loanParams = tokenLoanParams[tokenId];     require(         // Addition is safe: both summands are smaller than 256 bits         uint256(loan.startTime) + loanParams.duration &gt; block.timestamp,         "NFTPair: loan expired"     );      uint128 principal = loanParams.valuation;      // No underflow: loan.startTime is only ever set to a block timestamp     // Cast is safe: if this overflows, then all loans have expired anyway     uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();     uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;     amount = principal + interest;      uint256 totalShare = bentoBox.toShare(asset, amount, false);     uint256 feeShare = bentoBox.toShare(asset, fee, false);      address from;     if (skim) {         require(bentoBox.balanceOf(asset, address(this)) &gt;= (totalShare + feesEarnedShare), "NFTPair: skim too much");         from = address(this);         // No overflow: result fits in BentoBox     } else {         bentoBox.transfer(asset, msg.sender, address(this), feeShare);         from = msg.sender;     }     // No underflow: PROTOCOL_FEE_BPS &lt; BPS by construction.     feesEarnedShare += feeShare;     delete tokenLoan[tokenId];      bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);     collateral.transferFrom(address(this), loan.borrower, tokenId);      emit LogRepay(from, tokenId); }  uint8 internal constant ACTION_REPAY = 2; uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;  uint8 internal constant ACTION_REQUEST_LOAN = 12; uint8 internal constant ACTION_LEND = 13;  // Function on BentoBox uint8 internal constant ACTION_BENTO_DEPOSIT = 20; uint8 internal constant ACTION_BENTO_WITHDRAW = 21; uint8 internal constant ACTION_BENTO_TRANSFER = 22; uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23; uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;  // Any external call (except to BentoBox) uint8 internal constant ACTION_CALL = 30;  // Signed requests uint8 internal constant ACTION_REQUEST_AND_BORROW = 40; uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;  int256 internal constant USE_VALUE1 = -1; int256 internal constant USE_VALUE2 = -2;  /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`. function _num(     int256 inNum,     uint256 value1,     uint256 value2 ) internal pure returns (uint256 outNum) {     outNum = inNum &gt;= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2); }  /// @dev Helper function for depositing into `bentoBox`. function _bentoDeposit(     bytes memory data,     uint256 value,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors     share = int256(_num(share, value1, value2));     return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share)); }  /// @dev Helper function to withdraw from the `bentoBox`. function _bentoWithdraw(     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (uint256, uint256) {     (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));     return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2)); }  /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure. /// Calls to `bentoBox` or `collateral` are not allowed for security reasons. /// This also means that calls made from this contract shall *not* be trusted. function _call(     uint256 value,     bytes memory data,     uint256 value1,     uint256 value2 ) internal returns (bytes memory, uint8) {     (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(         data,         (address, bytes, bool, bool, uint8)     );      if (useValue1 &amp;&amp; !useValue2) {         callData = abi.encodePacked(callData, value1);     } else if (!useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value2);     } else if (useValue1 &amp;&amp; useValue2) {         callData = abi.encodePacked(callData, value1, value2);     }      require(callee != address(bentoBox) &amp;&amp; callee != address(collateral) &amp;&amp; callee != address(this), "NFTPair: can't call");      (bool success, bytes memory returnData) = callee.call{value: value}(callData);     require(success, "NFTPair: call failed");     return (returnData, returnValues); }  /// @notice Executes a set of actions and allows composability (contract calls) to other contracts. /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations). /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions. /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`. /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments. /// @return value1 May contain the first positioned return value of the last executed action (if applicable). /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable). function cook(     uint8[] calldata actions,     uint256[] calldata values,     bytes[] calldata datas ) external payable returns (uint256 value1, uint256 value2) {     for (uint256 i = 0; i &lt; actions.length; i++) {         uint8 action = actions[i];         if (action == ACTION_REPAY) {             (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));             repay(tokenId, skim);         } else if (action == ACTION_REMOVE_COLLATERAL) {             (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));             removeCollateral(tokenId, to);         } else if (action == ACTION_REQUEST_LOAN) {             (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(                 datas[i],                 (uint256, TokenLoanParams, address, bool)             );             requestLoan(tokenId, params, to, skim);         } else if (action == ACTION_LEND) {             (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));             lend(tokenId, params, skim);         } else if (action == ACTION_BENTO_SETAPPROVAL) {             (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(                 datas[i],                 (address, address, bool, uint8, bytes32, bytes32)             );             bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);         } else if (action == ACTION_BENTO_DEPOSIT) {             (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);         } else if (action == ACTION_BENTO_WITHDRAW) {             (value1, value2) = _bentoWithdraw(datas[i], value1, value2);         } else if (action == ACTION_BENTO_TRANSFER) {             (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));             bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));         } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {             (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));             bentoBox.transferMultiple(token, msg.sender, tos, shares);         } else if (action == ACTION_CALL) {             (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);              if (returnValues == 1) {                 (value1) = abi.decode(returnData, (uint256));             } else if (returnValues == 2) {                 (value1, value2) = abi.decode(returnData, (uint256, uint256));             }         } else if (action == ACTION_REQUEST_AND_BORROW) {             (                 uint256 tokenId,                 address lender,                 address recipient,                 TokenLoanParams memory params,                 bool skimCollateral,                 bool anyTokenId,                 SignatureParams memory signature             ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));             requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);         } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {             (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi                 .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));             takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);         }     } }  /// @notice Withdraws the fees accumulated. function withdrawFees() public {     address to = masterContract.feeTo();      uint256 _share = feesEarnedShare;     if (_share &gt; 0) {         bentoBox.transfer(asset, address(this), to, _share);         feesEarnedShare = 0;     }      emit LogWithdrawFees(to, _share); }  /// @notice Sets the beneficiary of fees accrued in liquidations. /// MasterContract Only Admin function. /// @param newFeeTo The address of the receiver. function setFeeTo(address newFeeTo) public onlyOwner {     feeTo = newFeeTo;     emit LogFeeTo(newFeeTo); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-29-08 22:50:37 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol";
import "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol";
import "@boringcrypto/boring-solidity/contracts/Domain.sol";
import "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";
import "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol";
import "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/INFTOracle.sol";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // "Shares" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns "second-order" interest-on-interest, which
    // itself earns "third-order" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why "at least"? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator "wins"; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the "true" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in "total"
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), "NFTPair: already initialized");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), "NFTPair: bad pair");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, "NFTPair: not the lender");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                "NFTPair: worse params"
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert("NFTPair: no collateral");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, "NFTPair: loan exists");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), "NFTPair: skim failed");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, "NFTPair: not the borrower");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, "NFTPair: not the lender");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, "NFT is still valued");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, "NFTPair: not available");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            "NFTPair: bad params"
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, "Oracle: price too low.");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                "NFTPair: skim too much"
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256("Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256("Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), "NFTPair: LendingClub does not like you");
        } else {
            require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, "NFTPair: signature invalid");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, "NFTPair: signature expired");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, "NFTPair: signature invalid");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the "theoretical" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, "NFTPair: no loan");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            "NFTPair: loan expired"
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), "NFTPair: skim too much");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), "NFTPair: can't call");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, "NFTPair: call failed");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

