[2024-28-08 07:49:27 INFO] **[Preprocessing]**

**ChatDev Starts** (20240828074926)

**Timestamp**: 20240828074926

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}

**project_name**: RealWorld_BA_105_HolyPaladinToken

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_105_HolyPaladinToken_RealWord_20240828074926.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-28-08 07:49:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n\n    // Event\n\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount &gt; 0, "hPAL: incorrect amount");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n\n    }\n\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n\n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        require(emergency, "hPAL: Not emergency");\n\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:49:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:49:27 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-28-08 07:49:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:49:34 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25067
completion_tokens: 1
total_tokens: 25068
cost: $-1.000000


[2024-28-08 07:49:34 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Let's

[2024-28-08 07:49:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n    // Event\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n        pal = IERC20(palToken);\n        transferOwnership(_admin);\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n        currentDropPerSecond = _startDropPerSecond;\n        dropDecreaseDuration = _dropDecreaseDuration;\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n        emit Cooldown(msg.sender);\n    }\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        require(amount &gt; 0, "hPAL: incorrect amount");\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n    // ---------------\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n        uint256 nbCheckpoints = totalLocks.length;\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n        estimatedClaimableRewards += accruedRewards;\n        return estimatedClaimableRewards;\n    }\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n        if(nbLocks == 0) return currentVotes;\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n        return currentVotes + bonusVotes;\n    }\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n        return votes + bonusVotes;\n    }\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n    // ----------------\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n            return endDropPerSecond;\n        }\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n        return newDropPerSecond;\n    }\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n        return rewardIndex + ratio;\n    }\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n        return newIndex;\n    }\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n        if(userLastIndex != currentRewardsIndex){\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n                uint256 lockingRewards = 0;\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n    }\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n    // -----------------\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n        emit Stake(user, amount);\n        return amount;\n    }\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n        emit Unstake(user, burnAmount);\n        return burnAmount;\n    }\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n    }\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n            uint256 startTimestamp = block.timestamp;\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n        require(emergency, "hPAL: Not emergency");\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n        _burn(msg.sender, burnAmount);\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n        emit EmergencyUnstake(msg.sender, burnAmount);\n        return burnAmount;\n    }\n    // Utils\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n    // Admin methods\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n    // Event\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n        pal = IERC20(palToken);\n        transferOwnership(_admin);\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n        currentDropPerSecond = _startDropPerSecond;\n        dropDecreaseDuration = _dropDecreaseDuration;\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n        emit Cooldown(msg.sender);\n    }\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        require(amount &gt; 0, "hPAL: incorrect amount");\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n    // ---------------\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n        uint256 nbCheckpoints = totalLocks.length;\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n        estimatedClaimableRewards += accruedRewards;\n        return estimatedClaimableRewards;\n    }\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n        if(nbLocks == 0) return currentVotes;\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n        return currentVotes + bonusVotes;\n    }\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n        return votes + bonusVotes;\n    }\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n    // ----------------\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n            return endDropPerSecond;\n        }\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n        return newDropPerSecond;\n    }\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n        return rewardIndex + ratio;\n    }\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n        return newIndex;\n    }\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n        if(userLastIndex != currentRewardsIndex){\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n                uint256 lockingRewards = 0;\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n    }\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n    // -----------------\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n        emit Stake(user, amount);\n        return amount;\n    }\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n        emit Unstake(user, burnAmount);\n        return burnAmount;\n    }\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n    }\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n            uint256 startTimestamp = block.timestamp;\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n        require(emergency, "hPAL: Not emergency");\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n        _burn(msg.sender, burnAmount);\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n        emit EmergencyUnstake(msg.sender, burnAmount);\n        return burnAmount;\n    }\n    // Utils\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n    // Admin methods\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:49:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:49:35 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;
import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";
/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;

    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;
    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days
    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks
    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years
    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;
    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }
    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;
    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }
    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;
    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;
    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }
    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }
    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;
    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;
    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;
    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;
    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;
    /** @notice Allow emergency withdraws  */
    bool public emergency = false;
    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;
    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;
    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;
    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;
    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;
    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;
    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 
    // Event
    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);
    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));
        pal = IERC20(palToken);
        transferOwnership(_admin);
        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;
        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;
        currentDropPerSecond = _startDropPerSecond;
        dropDecreaseDuration = _dropDecreaseDuration;
        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;
        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }

    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }
    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");
        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;
        emit Cooldown(msg.sender);
    }
    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }
    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }
    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }
    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }
    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }
    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }
    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }
    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }
    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }
    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        require(amount > 0, "hPAL: incorrect amount");
        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];
        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;
        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);
        emit ClaimRewards(msg.sender, claimAmount);
    }
    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }
    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }
    // ---------------
    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);
        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }
    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }
    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }
    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }
    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }
    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }
    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );
        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );
        uint256 nbCheckpoints = totalLocks.length;
        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }
        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }
    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }
    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }
    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];
        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;
        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }
        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);
        estimatedClaimableRewards += accruedRewards;
        return estimatedClaimableRewards;
    }
    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }
    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power
        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;
        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;
        if(nbLocks == 0) return currentVotes;
        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;
        return currentVotes + bonusVotes;
    }
    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);

        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;
        return votes + bonusVotes;
    }
    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );
        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);
        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }
        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }
    // ----------------
    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }
    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }
            return endDropPerSecond;
        }
        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month
        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;
        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;
        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;
        return newDropPerSecond;
    }
    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;
        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;
        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;
         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;
        return rewardIndex + ratio;
    }
    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block
        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();
        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;
        return newIndex;
    }
    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }
    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;
        if(userLastIndex != currentRewardsIndex){
            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;
                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;
                uint256 lockingRewards = 0;
                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;
                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;
                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);
                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];
                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;
                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }
                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }
                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }
    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();
        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;
        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block
        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;
    }
    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);
        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 
        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer
            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }
        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }
    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );
        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );
        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;
        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }
        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }
    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");
        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;
        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }
        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }
    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");
        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);
        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }
        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }
    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }
            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }
    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;
        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }
    // -----------------
    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    
        _mint(user, amount); //We mint hPAL 1:1 with PAL
        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);
        emit Stake(user, amount);
        return amount;
    }
    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");
        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");
        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()
        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;
        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);
        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()
        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);
        emit Unstake(user, burnAmount);
        return burnAmount;
    }
    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];
        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;
        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);
        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;
        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;
        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;
        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);
    }
    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }
    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");
        if(userLocks[user].length == 0){
            //User 1st Lock
            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));
            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);
            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));
            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;
            uint256 startTimestamp = block.timestamp;
            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired
                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");
                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock
                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }
            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);
                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){
                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }
            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }
    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");
        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;
        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");
        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));
        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;
        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));
        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }
    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");
        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;
        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");
        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");
        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));
        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));
        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;
        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;
        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);
        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }
    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;
        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));
        emit DelegateChanged(delegator, oldDelegatee, delegatee);
        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }
    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {
        require(emergency, "hPAL: Not emergency");
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");
        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));
            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }
        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;
        _burn(msg.sender, burnAmount);
        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);
        emit EmergencyUnstake(msg.sender, burnAmount);
        return burnAmount;
    }
    // Utils
    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 
    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }
    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }
    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }
    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }
    // Admin methods
    error IncorrectParameters();
    error DecreaseDurationNotOver();
    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }
    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }
    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;
import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";
/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;

    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;
    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days
    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks
    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years
    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;
    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }
    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;
    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }
    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;
    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;
    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }
    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }
    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;
    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;
    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;
    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;
    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;
    /** @notice Allow emergency withdraws  */
    bool public emergency = false;
    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;
    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;
    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;
    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;
    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;
    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;
    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 
    // Event
    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);
    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));
        pal = IERC20(palToken);
        transferOwnership(_admin);
        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;
        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;
        currentDropPerSecond = _startDropPerSecond;
        dropDecreaseDuration = _dropDecreaseDuration;
        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;
        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }

    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }
    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");
        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;
        emit Cooldown(msg.sender);
    }
    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }
    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }
    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }
    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }
    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }
    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }
    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }
    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }
    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }
    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        require(amount > 0, "hPAL: incorrect amount");
        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];
        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;
        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);
        emit ClaimRewards(msg.sender, claimAmount);
    }
    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }
    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }
    // ---------------
    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);
        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }
    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }
    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }
    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }
    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }
    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }
    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );
        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );
        uint256 nbCheckpoints = totalLocks.length;
        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }
        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }
    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }
    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }
    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];
        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;
        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }
        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);
        estimatedClaimableRewards += accruedRewards;
        return estimatedClaimableRewards;
    }
    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }
    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power
        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;
        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;
        if(nbLocks == 0) return currentVotes;
        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;
        return currentVotes + bonusVotes;
    }
    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);

        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;
        return votes + bonusVotes;
    }
    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );
        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);
        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }
        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }
    // ----------------
    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }
    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }
            return endDropPerSecond;
        }
        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month
        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;
        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;
        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;
        return newDropPerSecond;
    }
    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;
        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;
        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;
         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;
        return rewardIndex + ratio;
    }
    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block
        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();
        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;
        return newIndex;
    }
    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }
    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;
        if(userLastIndex != currentRewardsIndex){
            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;
                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;
                uint256 lockingRewards = 0;
                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;
                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;
                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);
                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];
                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;
                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }
                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }
                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }
    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();
        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;
        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block
        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;
    }
    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);
        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 
        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer
            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }
        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }
    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );
        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );
        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;
        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }
        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }
    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");
        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;
        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }
        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }
    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");
        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);
        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }
        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);
        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }
    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }
            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }
    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;
        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }
    // -----------------
    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    
        _mint(user, amount); //We mint hPAL 1:1 with PAL
        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);
        emit Stake(user, amount);
        return amount;
    }
    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");
        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");
        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()
        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;
        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);
        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()
        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);
        emit Unstake(user, burnAmount);
        return burnAmount;
    }
    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];
        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;
        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);
        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;
        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;
        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;
        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);
    }
    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }
    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");
        if(userLocks[user].length == 0){
            //User 1st Lock
            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));
            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);
            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));
            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;
            uint256 startTimestamp = block.timestamp;
            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired
                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");
                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock
                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }
            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);
                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){
                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }
            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }
    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");
        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;
        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");
        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));
        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;
        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));
        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }
    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");
        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;
        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");
        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");
        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));
        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));
        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;
        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;
        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);
        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }
    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;
        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));
        emit DelegateChanged(delegator, oldDelegatee, delegatee);
        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }
    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {
        require(emergency, "hPAL: Not emergency");
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");
        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));
            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }
        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;
        _burn(msg.sender, burnAmount);
        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);
        emit EmergencyUnstake(msg.sender, burnAmount);
        return burnAmount;
    }
    // Utils
    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 
    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }
    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }
    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }
    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }
    // Admin methods
    error IncorrectParameters();
    error DecreaseDurationNotOver();
    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }
    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }
    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-28-08 07:49:40 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:49:40 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 37654
completion_tokens: 1
total_tokens: 37655
cost: $-1.000000


[2024-28-08 07:49:40 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Security

[2024-28-08 07:49:40 INFO] **[Seminar Conclusion]**:

 Security

[2024-28-08 07:49:40 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-28-08 07:49:40 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-28-08 07:49:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n\n    // Event\n\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount &gt; 0, "hPAL: incorrect amount");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n\n    }\n\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n\n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        require(emergency, "hPAL: Not emergency");\n\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:49:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:49:40 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-28-08 07:49:44 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:49:44 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25058
completion_tokens: 1
total_tokens: 25059
cost: $-1.000000


[2024-28-08 07:49:44 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

###

[2024-28-08 07:49:44 INFO] **[Seminar Conclusion]**:

 ###

[2024-28-08 07:49:44 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-28-08 07:49:44 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:49:44 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:49:44 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-28-08 07:49:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:49:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12588
completion_tokens: 764
total_tokens: 13352
cost: $-1.000000


[2024-28-08 07:49:54 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Based on the provided smart contract code for the Holy Paladin Token (hPAL), here is a summary of the identified security vulnerabilities and concerns:

### Summary of Security Vulnerabilities

1. **Emergency Mode Risks**:
   - The contract allows the owner to trigger an emergency mode, which can bypass cooldowns and locks. This could potentially lead to misuse by the owner, allowing them to withdraw funds without restrictions.

2. **Lack of Reentrancy Protection**:
   - Functions that transfer tokens (e.g., `unstake`, `emergencyWithdraw`) do not implement reentrancy guards. This could expose the contract to reentrancy attacks, where an attacker could exploit the transfer logic to drain funds.

3. **Insufficient Input Validation**:
   - Some functions lack comprehensive input validation. For example, the `setKickRatio` function allows setting a kick ratio to zero, which may not be intended. Additionally, the `setEndDropPerSecond` function does not check if the new value is less than the current value.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, the use of custom safe functions (e.g., `safe32`, `safe48`) could still lead to unexpected behavior if not properly handled.

5. **Gas Limit Issues**:
   - Functions that manipulate arrays (like `userLocks` and `totalLocks`) could run into gas limit issues if the number of locks grows significantly. This could lead to failed transactions when users attempt to unlock or manipulate their locks.

6. **Delegate Voting Power Risks**:
   - The delegation mechanism allows users to delegate their voting power, but it does not prevent a malicious delegate from acting against the interests of the delegator. There is no mechanism for revoking delegation or ensuring that delegates act in good faith.

7. **Lack of Events for Critical State Changes**:
   - While there are events for some actions, critical state changes (like changes to the emergency mode or kick ratio) could benefit from additional events to enhance transparency and traceability.

8. **Potential for Abuse of `kick` Function**:
   - The `kick` function allows users to be forcibly removed from their locks. This could be exploited by malicious users to penalize others, especially if they can coordinate with other users.

### Comprehensive Analysis Report

The Holy Paladin Token (hPAL) contract exhibits several security vulnerabilities that could be exploited if not addressed. The most pressing concerns include the potential for misuse of emergency functions, lack of reentrancy protection, and insufficient input validation. The delegation mechanism also poses risks, as it does not safeguard against malicious actions by delegates.

To enhance the security of the contract, the following recommendations are proposed:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to prevent reentrancy attacks on critical functions.

2. **Strengthen Input Validation**: Ensure all input parameters are validated to prevent unintended states, especially in functions that modify critical parameters.

3. **Review Emergency Functions**: Consider implementing multi-signature requirements for emergency actions to mitigate risks associated with potential misuse by a single owner.

4. **Enhance Event Logging**: Add events for critical state changes to improve transparency and allow for better tracking of contract activity.

5. **Limit Delegate Power**: Introduce mechanisms to allow users to revoke delegation easily and ensure that delegates cannot act against the interests of the delegators.

6. **Gas Optimization**: Consider optimizing functions that manipulate arrays to prevent gas limit issues, especially as user activity increases.

By addressing these vulnerabilities, the Holy Paladin Token contract can significantly improve its security posture and protect users' funds and interests.

[2024-28-08 07:49:54 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Holy Paladin Token (hPAL), here is a summary of the identified security vulnerabilities and concerns:

### Summary of Security Vulnerabilities

1. **Emergency Mode Risks**:
   - The contract allows the owner to trigger an emergency mode, which can bypass cooldowns and locks. This could potentially lead to misuse by the owner, allowing them to withdraw funds without restrictions.

2. **Lack of Reentrancy Protection**:
   - Functions that transfer tokens (e.g., `unstake`, `emergencyWithdraw`) do not implement reentrancy guards. This could expose the contract to reentrancy attacks, where an attacker could exploit the transfer logic to drain funds.

3. **Insufficient Input Validation**:
   - Some functions lack comprehensive input validation. For example, the `setKickRatio` function allows setting a kick ratio to zero, which may not be intended. Additionally, the `setEndDropPerSecond` function does not check if the new value is less than the current value.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, the use of custom safe functions (e.g., `safe32`, `safe48`) could still lead to unexpected behavior if not properly handled.

5. **Gas Limit Issues**:
   - Functions that manipulate arrays (like `userLocks` and `totalLocks`) could run into gas limit issues if the number of locks grows significantly. This could lead to failed transactions when users attempt to unlock or manipulate their locks.

6. **Delegate Voting Power Risks**:
   - The delegation mechanism allows users to delegate their voting power, but it does not prevent a malicious delegate from acting against the interests of the delegator. There is no mechanism for revoking delegation or ensuring that delegates act in good faith.

7. **Lack of Events for Critical State Changes**:
   - While there are events for some actions, critical state changes (like changes to the emergency mode or kick ratio) could benefit from additional events to enhance transparency and traceability.

8. **Potential for Abuse of `kick` Function**:
   - The `kick` function allows users to be forcibly removed from their locks. This could be exploited by malicious users to penalize others, especially if they can coordinate with other users.

### Comprehensive Analysis Report

The Holy Paladin Token (hPAL) contract exhibits several security vulnerabilities that could be exploited if not addressed. The most pressing concerns include the potential for misuse of emergency functions, lack of reentrancy protection, and insufficient input validation. The delegation mechanism also poses risks, as it does not safeguard against malicious actions by delegates.

To enhance the security of the contract, the following recommendations are proposed:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to prevent reentrancy attacks on critical functions.

2. **Strengthen Input Validation**: Ensure all input parameters are validated to prevent unintended states, especially in functions that modify critical parameters.

3. **Review Emergency Functions**: Consider implementing multi-signature requirements for emergency actions to mitigate risks associated with potential misuse by a single owner.

4. **Enhance Event Logging**: Add events for critical state changes to improve transparency and allow for better tracking of contract activity.

5. **Limit Delegate Power**: Introduce mechanisms to allow users to revoke delegation easily and ensure that delegates cannot act against the interests of the delegators.

6. **Gas Optimization**: Consider optimizing functions that manipulate arrays to prevent gas limit issues, especially as user activity increases.

By addressing these vulnerabilities, the Holy Paladin Token contract can significantly improve its security posture and protect users' funds and interests.

[2024-28-08 07:49:54 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-28-08 07:49:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n\n    // Event\n\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount &gt; 0, "hPAL: incorrect amount");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n\n    }\n\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n\n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        require(emergency, "hPAL: Not emergency");\n\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:49:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:49:54 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-28-08 07:49:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:49:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25058
completion_tokens: 1
total_tokens: 25059
cost: $-1.000000


[2024-28-08 07:49:58 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

###

[2024-28-08 07:49:58 INFO] **[Seminar Conclusion]**:

 ###

[2024-28-08 07:49:58 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-28-08 07:49:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:49:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:49:58 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-28-08 07:50:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:50:08 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12588
completion_tokens: 769
total_tokens: 13357
cost: $-1.000000


[2024-28-08 07:50:08 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

### Summary of Security Vulnerabilities in the Holy Paladin Token (hPAL) Contract

1. **Emergency Mode Risks**:
   - The contract has an emergency mode that can be triggered by the owner. While this feature is useful for mitigating risks, it can also be abused if the owner acts maliciously or if the private key is compromised. This could lead to unauthorized withdrawals or changes in contract behavior.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens (e.g., `unstake`, `emergencyWithdraw`) do not implement reentrancy guards. This could allow an attacker to exploit the contract by recursively calling these functions before the state changes are finalized.

3. **Lack of Input Validation**:
   - Several functions do not adequately validate input parameters. For instance, the `unstake` function does not check if the amount to unstake exceeds the user's available balance, which could lead to unexpected behavior.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow protection, the use of custom safe functions (e.g., `safe32`, `safe48`) could still introduce risks if not implemented correctly. Care must be taken to ensure that these functions are used consistently and correctly throughout the contract.

5. **Cooldown Mechanism Flaws**:
   - The cooldown mechanism may allow users to manipulate their cooldown periods through transfers, potentially leading to abuse. The logic for calculating new cooldowns could be exploited if not properly secured.

6. **Delegation Risks**:
   - The delegation mechanism allows users to delegate their voting power. However, if a malicious actor gains control of a user's account, they could delegate votes without the user's consent, leading to potential governance issues.

7. **Reward Calculation Complexity**:
   - The reward calculation logic is complex and may contain hidden bugs. If not thoroughly tested, it could lead to incorrect reward distributions, which could be exploited by users who understand the mechanics.

8. **Lack of Access Control on Critical Functions**:
   - Certain functions that modify critical parameters (e.g., `setEndDropPerSecond`, `setKickRatio`) are only restricted to the owner. If the owner account is compromised, an attacker could manipulate these parameters to their advantage.

### Comprehensive Analysis Report

The Holy Paladin Token (hPAL) contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The presence of an emergency mode, while beneficial for risk mitigation, introduces a single point of failure if the owner's account is compromised. The lack of reentrancy guards in critical functions that involve token transfers poses a significant risk, as attackers could exploit this to drain funds.

Input validation is insufficient in several areas, particularly in functions that handle user balances, which could lead to unexpected behaviors. Although Solidity 0.8.x provides some protections against integer overflow and underflow, reliance on custom safe functions necessitates careful implementation to avoid introducing new vulnerabilities.

The cooldown mechanism's design may allow for manipulation, and the delegation system could lead to governance issues if not properly secured. The complexity of the reward calculation logic raises concerns about potential bugs that could be exploited, especially if users can predict or manipulate reward distributions.

Access control measures are in place for critical functions, but the reliance on a single owner for these controls could be problematic if the owner's private key is compromised. 

In conclusion, while the hPAL contract has been designed with several features to enhance user engagement and governance, it is essential to address the identified vulnerabilities through rigorous testing, code audits, and the implementation of best practices in smart contract security. Recommendations include adding reentrancy guards, enhancing input validation, simplifying reward calculations, and considering a multi-signature wallet for ownership to mitigate risks associated with single-point failures.

[2024-28-08 07:50:08 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Holy Paladin Token (hPAL) Contract

1. **Emergency Mode Risks**:
   - The contract has an emergency mode that can be triggered by the owner. While this feature is useful for mitigating risks, it can also be abused if the owner acts maliciously or if the private key is compromised. This could lead to unauthorized withdrawals or changes in contract behavior.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens (e.g., `unstake`, `emergencyWithdraw`) do not implement reentrancy guards. This could allow an attacker to exploit the contract by recursively calling these functions before the state changes are finalized.

3. **Lack of Input Validation**:
   - Several functions do not adequately validate input parameters. For instance, the `unstake` function does not check if the amount to unstake exceeds the user's available balance, which could lead to unexpected behavior.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow protection, the use of custom safe functions (e.g., `safe32`, `safe48`) could still introduce risks if not implemented correctly. Care must be taken to ensure that these functions are used consistently and correctly throughout the contract.

5. **Cooldown Mechanism Flaws**:
   - The cooldown mechanism may allow users to manipulate their cooldown periods through transfers, potentially leading to abuse. The logic for calculating new cooldowns could be exploited if not properly secured.

6. **Delegation Risks**:
   - The delegation mechanism allows users to delegate their voting power. However, if a malicious actor gains control of a user's account, they could delegate votes without the user's consent, leading to potential governance issues.

7. **Reward Calculation Complexity**:
   - The reward calculation logic is complex and may contain hidden bugs. If not thoroughly tested, it could lead to incorrect reward distributions, which could be exploited by users who understand the mechanics.

8. **Lack of Access Control on Critical Functions**:
   - Certain functions that modify critical parameters (e.g., `setEndDropPerSecond`, `setKickRatio`) are only restricted to the owner. If the owner account is compromised, an attacker could manipulate these parameters to their advantage.

### Comprehensive Analysis Report

The Holy Paladin Token (hPAL) contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The presence of an emergency mode, while beneficial for risk mitigation, introduces a single point of failure if the owner's account is compromised. The lack of reentrancy guards in critical functions that involve token transfers poses a significant risk, as attackers could exploit this to drain funds.

Input validation is insufficient in several areas, particularly in functions that handle user balances, which could lead to unexpected behaviors. Although Solidity 0.8.x provides some protections against integer overflow and underflow, reliance on custom safe functions necessitates careful implementation to avoid introducing new vulnerabilities.

The cooldown mechanism's design may allow for manipulation, and the delegation system could lead to governance issues if not properly secured. The complexity of the reward calculation logic raises concerns about potential bugs that could be exploited, especially if users can predict or manipulate reward distributions.

Access control measures are in place for critical functions, but the reliance on a single owner for these controls could be problematic if the owner's private key is compromised. 

In conclusion, while the hPAL contract has been designed with several features to enhance user engagement and governance, it is essential to address the identified vulnerabilities through rigorous testing, code audits, and the implementation of best practices in smart contract security. Recommendations include adding reentrancy guards, enhancing input validation, simplifying reward calculations, and considering a multi-signature wallet for ownership to mitigate risks associated with single-point failures.

[2024-28-08 07:50:08 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-28-08 07:50:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n\n    // Event\n\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount &gt; 0, "hPAL: incorrect amount");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n\n    }\n\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n\n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        require(emergency, "hPAL: Not emergency");\n\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:50:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:50:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-28-08 07:50:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:50:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25058
completion_tokens: 1
total_tokens: 25059
cost: $-1.000000


[2024-28-08 07:50:13 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

###

[2024-28-08 07:50:13 INFO] **[Seminar Conclusion]**:

 ###

[2024-28-08 07:50:13 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-28-08 07:50:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-28-08 07:50:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:50:13 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-28-08 07:50:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-28-08 07:50:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12588
completion_tokens: 704
total_tokens: 13292
cost: $-1.000000


[2024-28-08 07:50:23 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

### Summary of Security Vulnerabilities in the Holy Paladin Token (hPAL) Contract

1. **Emergency Mode Risks**:
   - The contract allows the owner to trigger an emergency mode that disables certain functionalities. If the emergency mode is activated, users may be unable to access their funds or execute normal operations, which could lead to a denial of service.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens (e.g., `unstake`, `emergencyWithdraw`) do not implement checks-effects-interactions pattern, making them susceptible to reentrancy attacks. An attacker could exploit this by calling the function recursively before the state changes are finalized.

3. **Insufficient Input Validation**:
   - Some functions do not adequately validate input parameters, such as `amount` and `duration`. For example, in the `lock` function, while there are checks for minimum and maximum lock durations, there could be additional checks to ensure that the `amount` is not zero.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, the contract still uses custom safe functions (e.g., `safe32`, `safe48`). If these functions are misused or if the contract is ever migrated to an earlier version of Solidity, it could lead to vulnerabilities.

5. **Lack of Access Control**:
   - Certain functions, such as `setEndDropPerSecond`, can be called by the owner without any restrictions on the parameters. This could lead to potential abuse if the owner sets an extremely high drop rate, affecting the tokenomics adversely.

6. **Token Transfer Logic**:
   - The `_beforeTokenTransfer` function allows transfers only if the sender has an available balance. However, it does not account for the potential for a user to have a locked balance that could be transferred, leading to confusion about the actual available balance.

7. **User Lock Management**:
   - The logic for managing user locks is complex and could lead to unintended consequences, such as users being locked out of their funds if they mismanage their locks or if there are bugs in the locking logic.

8. **Reward Calculation Complexity**:
   - The reward calculation mechanism is intricate and may lead to discrepancies in reward distribution. If not properly audited, it could result in users receiving incorrect amounts of rewards.

### Comprehensive Analysis Report

The Holy Paladin Token (hPAL) contract exhibits several security vulnerabilities that could potentially compromise the integrity and usability of the token. The most pressing concerns include the risks associated with emergency mode, which could lead to a denial of service for users, and the lack of proper reentrancy protections in critical functions that handle token transfers.

Additionally, insufficient input validation and complex user lock management could lead to user confusion and mismanagement of funds. The reward calculation mechanism, while designed to incentivize users, introduces complexity that may result in unintended consequences if not thoroughly tested.

To mitigate these vulnerabilities, it is recommended to:

- Implement the checks-effects-interactions pattern in all functions that involve external calls.
- Enhance input validation across all functions to ensure that parameters are within acceptable ranges.
- Simplify the locking and reward mechanisms to reduce complexity and potential for errors.
- Conduct a thorough audit of the contract, focusing on the reward distribution logic and user lock management.

By addressing these vulnerabilities, the hPAL contract can enhance its security posture and provide a more reliable experience for its users.

[2024-28-08 07:50:23 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Holy Paladin Token (hPAL) Contract

1. **Emergency Mode Risks**:
   - The contract allows the owner to trigger an emergency mode that disables certain functionalities. If the emergency mode is activated, users may be unable to access their funds or execute normal operations, which could lead to a denial of service.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens (e.g., `unstake`, `emergencyWithdraw`) do not implement checks-effects-interactions pattern, making them susceptible to reentrancy attacks. An attacker could exploit this by calling the function recursively before the state changes are finalized.

3. **Insufficient Input Validation**:
   - Some functions do not adequately validate input parameters, such as `amount` and `duration`. For example, in the `lock` function, while there are checks for minimum and maximum lock durations, there could be additional checks to ensure that the `amount` is not zero.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, the contract still uses custom safe functions (e.g., `safe32`, `safe48`). If these functions are misused or if the contract is ever migrated to an earlier version of Solidity, it could lead to vulnerabilities.

5. **Lack of Access Control**:
   - Certain functions, such as `setEndDropPerSecond`, can be called by the owner without any restrictions on the parameters. This could lead to potential abuse if the owner sets an extremely high drop rate, affecting the tokenomics adversely.

6. **Token Transfer Logic**:
   - The `_beforeTokenTransfer` function allows transfers only if the sender has an available balance. However, it does not account for the potential for a user to have a locked balance that could be transferred, leading to confusion about the actual available balance.

7. **User Lock Management**:
   - The logic for managing user locks is complex and could lead to unintended consequences, such as users being locked out of their funds if they mismanage their locks or if there are bugs in the locking logic.

8. **Reward Calculation Complexity**:
   - The reward calculation mechanism is intricate and may lead to discrepancies in reward distribution. If not properly audited, it could result in users receiving incorrect amounts of rewards.

### Comprehensive Analysis Report

The Holy Paladin Token (hPAL) contract exhibits several security vulnerabilities that could potentially compromise the integrity and usability of the token. The most pressing concerns include the risks associated with emergency mode, which could lead to a denial of service for users, and the lack of proper reentrancy protections in critical functions that handle token transfers.

Additionally, insufficient input validation and complex user lock management could lead to user confusion and mismanagement of funds. The reward calculation mechanism, while designed to incentivize users, introduces complexity that may result in unintended consequences if not thoroughly tested.

To mitigate these vulnerabilities, it is recommended to:

- Implement the checks-effects-interactions pattern in all functions that involve external calls.
- Enhance input validation across all functions to ensure that parameters are within acceptable ranges.
- Simplify the locking and reward mechanisms to reduce complexity and potential for errors.
- Conduct a thorough audit of the contract, focusing on the reward distribution logic and user lock management.

By addressing these vulnerabilities, the hPAL contract can enhance its security posture and provide a more reliable experience for its users.

[2024-28-08 07:50:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "./open-zeppelin/ERC20.sol";\nimport "./open-zeppelin/utils/Ownable.sol";\nimport "./open-zeppelin/interfaces/IERC20.sol";\nimport "./open-zeppelin/libraries/SafeERC20.sol";\nimport "./open-zeppelin/utils/Math.sol";\n\n/ @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    / @notice Seconds in a Week /\n    uint256 public constant WEEK = 604800;\n    / @notice Seconds in a Month /\n    uint256 public constant MONTH = 2629800;\n    / @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    / @notice Max BPS value (100%) /\n    uint256 public constant MAX_BPS = 10000;\n    / @notice Seconds in a Year /\n    uint256 public constant ONE_YEAR = 31557600;\n\n    / @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    / @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  /\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    / @notice Period to unlock/re-lock tokens without possibility of punishement   /\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    / @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    / @notice Maximum duration of a Lock  /\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    / @notice Address of the PAL token  /\n    IERC20 public immutable pal;\n\n    / @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    / @notice Array of all user Locks, ordered from oldest to newest  /\n    mapping(address =&gt; UserLock[]) public userLocks;\n\n    / @notice Struct trancking the total amount locked  /\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    / @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    / @notice List of TotalLocks, ordered from oldest to newest  /\n    TotalLock[] public totalLocks;\n\n    / @notice User Cooldowns  /\n    mapping(address =&gt; uint256) public cooldowns;\n\n    / @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    / @notice Checkpoints for users Delegates  /\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    / @notice mapping tracking the Delegator for each Delegatee  /\n    mapping(address =&gt; address) public delegates;\n\n    / @notice List of Vote checkpoints for each user  */\n    mapping(address =&gt; Checkpoint[]) public checkpoints;\n\n    / @notice List of Delegate checkpoints for each user  /\n    mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;\n\n    / @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  /\n    uint256 public kickRatioPerWeek = 1000;\n\n    / @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    / @notice Allow emergency withdraws  /\n    bool public emergency = false;\n\n    / @notice Address of the vault holding the PAL rewards  /\n    address public immutable rewardsVault;\n\n    / @notice Global reward index  */\n    uint256 public rewardIndex;\n    / @notice Timstamp of last update for global reward index  /\n    uint256 public lastRewardUpdate;\n\n    / @notice Amount of rewards distriubted per second at the start  /\n    uint256 public immutable startDropPerSecond;\n    / @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    / @notice Current amount of rewards distriubted per second  /\n    uint256 public currentDropPerSecond;\n    / @notice Timestamp of last update for currentDropPerSecond  /\n    uint256 public lastDropUpdate;\n    / @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    / @notice Timestamp: start of the DropPerSecond decrease period  /\n    uint256 public immutable startDropTimestamp;\n\n    / @notice Last reward index for each user  /\n    mapping(address =&gt; uint256) public userRewardIndex;\n    / @notice Current amount of rewards claimable for the user  */\n    mapping(address =&gt; uint256) public claimableRewards;\n    / @notice Timestamp of last update for user rewards  /\n    mapping(address =&gt; uint256) public rewardsLastUpdate;\n\n    / @notice Base reward multiplier for lock  /\n    uint256 public immutable baseLockBonusRatio;\n    / @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    / @notice Maximum reward multiplier for maximum duration  /\n    uint256 public immutable maxLockBonusRatio;\n\n    / @notice Last updated Bonus Ratio for rewards  /\n    mapping(address =&gt; uint256) public userCurrentBonusRatio;\n    / @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address =&gt; uint256) public userBonusRatioDecrease;\n\n    / @notice Error raised if contract is turned in emergency mode /\n    error EmergencyBlock(); \n\n    // Event\n\n    / @notice Emitted when an user stake PAL in the contract /\n    event Stake(address indexed user, uint256 amount);\n    / @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    / @notice Emitted when an user triggers the cooldown period /\n    event Cooldown(address indexed user);\n    / @notice Emitted when an user creates or update its Lock /\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    / @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    / @notice Emitted when an user is kicked out of the Lock /\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    / @notice Emitted when an user claim the rewards /\n    event ClaimRewards(address indexed user, uint256 amount);\n    / @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    / @notice Emitted when the votes of a delegate is updated /\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    / @notice Emitted when un user withdraw through the emergency method /\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution &amp; DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /\n     * @notice Deposits PAL &amp; mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /\n     * @notice Updates the Cooldown for the caller\n     /\n    function cooldown() external {\n        require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /\n     * @notice Burns hPAL &amp; withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     /\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /\n     * @notice Increase the user current Lock duration (&amp; restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     /\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     /\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     /\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, "hPAL: cannot kick yourself");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     /\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /\n     * @notice Stake more PAL into hPAL &amp; add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it\'s done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     /\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     /\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount &gt; 0, "hPAL: incorrect amount");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     /\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /\n     * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     /\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     /\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     /\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     /\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     /\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     /\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     /\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // &amp; in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate &lt; block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     /\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     /\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) =&gt; the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates =&gt; decrease duration is over\n        if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don\'t want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) &amp; get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index &amp; current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) &gt; 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length &gt; 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user\'s Lock is not empty\n                    if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio &gt; 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0\n                                vars.bonusRatioDecrease = vars.previousBonusRatio;\n                                // In the case this update is made far after the end of the lock, this method would mean\n                                // the user could get a multiplier for longer than expected\n                                // We count on the Kick logic to avoid that scenario\n                            }\n\n                            // and calculate the locking rewards based on the locked balance &amp; \n                            // a ratio based on the rpevious one and the newly calculated one\n                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);\n                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;\n                        }\n                    }\n\n                }\n                // sum up the accrued rewards, and return it\n                accruedRewards = stakingRewards + lockingRewards;\n            }\n        }\n    }\n\n    // Update user reward state internal\n    function _updateUserRewards(address user) internal {\n        // Update the global reward state and get the latest index\n        uint256 newIndex = _updateRewardState();\n\n        // Called for minting &amp; burning, but we don\'t want to update for address 0x0\n        if(user == address(0)) return;\n\n        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block\n\n        // Update the user claimable rewards\n        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);\n        claimableRewards[user] += accruedRewards;\n        // Store the new Bonus Ratio\n        userCurrentBonusRatio[user] = newBonusRatio;\n        \n        // and set the current timestamp for last update, and the last used index for the user rewards\n        rewardsLastUpdate[user] = block.timestamp;\n        userRewardIndex[user] = newIndex;\n\n    }\n\n    / @dev Hook called before any transfer /\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0)) { //check must be skipped on minting\n            // Only allow the balance that is unlocked to be transfered\n            require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");\n        }\n\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(from);\n\n        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 \n\n        if(from != to) {\n            // Update user rewards before any change on their balance (staked and locked)\n            _updateUserRewards(to);\n            // =&gt; we don\'t want a self-transfer to double count new claimable rewards\n            // + no need to update the cooldown on a self-transfer\n\n            uint256 previousToBalance = balanceOf(to);\n            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n        }\n\n        // If from transfer all of its balance, reset the cooldown to 0\n        uint256 previousFromBalance = balanceOf(from);\n        if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {\n            cooldowns[from] = 0;\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // update delegation for the sender &amp; the receiver if they delegate\n        _moveDelegates(delegates[from], delegates[to], amount);\n    }\n\n    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {\n        require(\n            blockNumber &lt; block.number,\n            "hPAL: invalid blockNumber"\n        );\n\n        UserLock memory emptyLock = UserLock(\n            0,\n            0,\n            0,\n            0\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = userLocks[account].length;\n        if (nbCheckpoints == 0) return emptyLock;\n\n        // last checkpoint check\n        if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return userLocks[account][nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (userLocks[account][0].fromBlock &gt; blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (userLocks[account][mid].fromBlock == blockNumber) {\n                return userLocks[account][mid];\n            }\n            if (userLocks[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : userLocks[account][high - 1];\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){\n        require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = checkpoints[account].length;\n        if (nbCheckpoints == 0) return 0;\n\n        // last checkpoint check\n        if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return checkpoints[account][nbCheckpoints - 1].votes;\n        }\n\n        // no checkpoint old enough\n        if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (checkpoints[account][mid].fromBlock == blockNumber) {\n                return checkpoints[account][mid].votes;\n            }\n            if (checkpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : checkpoints[account][high - 1].votes;\n    }\n\n    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {\n        require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low &lt; high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    function _moveDelegates(address from, address to, uint256 amount) internal {\n        if (from != to &amp;&amp; amount &gt; 0) {\n            if (from != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[from].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes - amount;\n                _writeCheckpoint(from, newVotes);\n                emit DelegateVotesChanged(from, oldVotes, newVotes);\n            }\n\n            if (to != address(0)) {\n                // Calculate the change in voting power, then write a new checkpoint\n                uint256 nbCheckpoints = checkpoints[to].length;\n                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;\n                uint256 newVotes = oldVotes + amount;\n                _writeCheckpoint(to, newVotes);\n                emit DelegateVotesChanged(to, oldVotes, newVotes);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {\n        // write a new checkpoint for an user\n        uint pos = checkpoints[delegatee].length;\n\n        if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {\n            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);\n        } else {\n            uint32 blockNumber = safe32(block.number);\n            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));\n        }\n    }\n\n    // -----------------\n\n    function _stake(address user, uint256 amount) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n\n        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()\n        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    \n\n        _mint(user, amount); //We mint hPAL 1:1 with PAL\n\n        // Pull the PAL into this contract\n        pal.safeTransferFrom(user, address(this), amount);\n\n        emit Stake(user, amount);\n\n        return amount;\n    }\n\n    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        // Check if user in inside the allowed period base on its cooldown\n        uint256 userCooldown = cooldowns[user];\n        require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");\n        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");\n\n        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()\n\n        // Can only unstake was is available, need to unlock before\n        uint256 userAvailableBalance = _availableBalanceOf(user);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        // Burn the hPAL 1:1 with PAL\n        _burn(user, burnAmount);\n\n        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()\n\n        // Then transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit Unstake(user, burnAmount);\n\n        return burnAmount;\n    }\n\n    // Get the new cooldown for an user receiving hPAL (mint or transfer),\n    // based on receiver cooldown and sender cooldown\n    // Inspired by stkAAVE cooldown system\n    function _getNewReceiverCooldown(\n        uint256 senderCooldown,\n        uint256 amount,\n        address receiver,\n        uint256 receiverBalance\n    ) internal view returns(uint256) {\n        uint256 receiverCooldown = cooldowns[receiver];\n\n        // If receiver has no cooldown, no need to set a new one\n        if(receiverCooldown == 0) return 0;\n\n        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);\n\n        // If last receiver cooldown is expired, set it back to 0\n        if(receiverCooldown &lt; minValidCooldown) return 0;\n\n        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)\n        uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;\n\n        // If the sender cooldown is better, we keep the receiver cooldown\n        if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;\n\n        // Default new cooldown, weighted average based on the amount and the previous balance\n        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);\n\n    }\n\n    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }\n\n    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(amount != 0, "hPAL: Null amount");\n        uint256 userBalance = balanceOf(user);\n        require(amount &lt;= userBalance, "hPAL: Amount over balance");\n        require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");\n        require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");\n\n        if(userLocks[user].length == 0){\n            //User 1st Lock\n\n            userLocks[user].push(UserLock(\n                safe128(amount),\n                safe48(block.timestamp),\n                safe48(duration),\n                safe32(block.number)\n            ));\n\n            // find the reward multiplier based on the user lock duration\n            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n            userCurrentBonusRatio[user] = userLockBonusRatio;\n            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n\n            // Update total locked supply\n            currentTotalLocked += amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);\n        } \n        else {\n            // Get the current user Lock\n            uint256 currentUserLockIndex = userLocks[user].length - 1;\n            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n            // Calculate the end of the user current lock\n            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n            uint256 startTimestamp = block.timestamp;\n\n            if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) { \n                // User locked, and then unlocked\n                // or user lock expired\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n            }\n            else {\n                // Update of the current Lock : increase amount or increase duration\n                // or renew with the same parameters, but starting at the current timestamp\n                require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");\n                require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");\n\n                // If the method is called with INCREASE_AMOUNT, then we don\'t change the startTimestamp of the Lock\n\n                userLocks[user].push(UserLock(\n                    safe128(amount),\n                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),\n                    safe48(duration),\n                    safe32(block.number)\n                ));\n\n                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;\n            }\n\n            // If the duration is updated, re-calculate the multiplier for the Lock\n            if(action != LockAction.INCREASE_AMOUNT){\n                // find the reward multiplier based on the user lock duration\n                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);\n                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);\n\n                userCurrentBonusRatio[user] = userLockBonusRatio;\n                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;\n            }\n            \n            // Update total locked supply\n            if(amount != currentUserLock.amount){\n\n                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;\n                \n                currentTotalLocked += amount;\n                totalLocks.push(TotalLock(\n                    safe224(currentTotalLocked),\n                    safe32(block.number)\n                ));\n            }\n\n            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);\n        }\n    }\n\n    function _unlock(address user) internal {\n        require(user != address(0)); //Never supposed to happen, but security check\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user current Lock\n        // And calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Set the user Lock as an empty Lock\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        emit Unlock(user, currentUserLock.amount, currentTotalLocked);\n    }\n\n    function _kick(address user, address kicker) internal {\n        require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");\n        require(userLocks[user].length &gt; 0, "hPAL: No Lock");\n\n        // Get the user to kick current Lock\n        // and calculate the end of the Lock\n        uint256 currentUserLockIndex = userLocks[user].length - 1;\n        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];\n        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;\n\n        require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");\n        require(currentUserLock.amount &gt; 0, "hPAL: No Lock");\n\n        require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");\n\n        // Remove amount from total locked supply\n        currentTotalLocked -= currentUserLock.amount;\n        totalLocks.push(TotalLock(\n            safe224(currentTotalLocked),\n            safe32(block.number)\n        ));\n\n        // Set an empty Lock for the user\n        userLocks[user].push(UserLock(\n            safe128(0),\n            safe48(block.timestamp),\n            safe48(0),\n            safe32(block.number)\n        ));\n\n        // Remove the bonus multiplier\n        userCurrentBonusRatio[user] = 0;\n        userBonusRatioDecrease[user] = 0;\n\n        // Calculate the penalty for the Lock\n        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;\n        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;\n        uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ? \n            currentUserLock.amount : \n            (currentUserLock.amount * penaltyPercent) / MAX_BPS;\n\n        // Send penalties to the kicker\n        _transfer(user, kicker, penaltyAmount);\n\n        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        // Move delegation from the old delegate to the given delegate\n        address oldDelegatee = delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator);\n        delegates[delegator] = delegatee;\n\n        // update the the Delegate chekpoint for the delegatee\n        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));\n\n        emit DelegateChanged(delegator, oldDelegatee, delegatee);\n\n        // and write the checkpoints for Votes\n        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);\n    }\n\n    /\n     * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency\n     * @param amount amount to withdraw\n     * @param receiver address to receive the withdrawn funds\n     * @return uint256 : amount withdrawn\n     /\n    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {\n\n        require(emergency, "hPAL: Not emergency");\n\n        require(amount &gt; 0, "hPAL: Null amount");\n        require(receiver != address(0), "hPAL: Address Zero");\n\n        if(userLocks[msg.sender].length != 0){\n            // Check if the user has a Lock, and if so, fetch it\n            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n\n            // To remove the Lock and update the total locked\n            currentTotalLocked -= currentUserLock.amount;\n            totalLocks.push(TotalLock(\n                safe224(currentTotalLocked),\n                safe32(block.number)\n            ));\n\n            userLocks[msg.sender].push(UserLock(\n                safe128(0),\n                safe48(block.timestamp),\n                safe48(0),\n                safe32(block.number)\n            ));\n        }\n\n        // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger\n        uint256 userAvailableBalance = balanceOf(msg.sender);\n        uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;\n\n        _burn(msg.sender, burnAmount);\n\n        // Transfer the PAL to the user\n        pal.safeTransfer(receiver, burnAmount);\n\n        emit EmergencyUnstake(msg.sender, burnAmount);\n\n        return burnAmount;\n\n    }\n\n    // Utils\n\n    error Exceed224Bits(); \n    error Exceed128Bits(); \n    error Exceed48Bits(); \n    error Exceed32Bits(); \n\n    function safe32(uint n) internal pure returns (uint32) {\n        if(n &gt; type(uint32).max) revert Exceed32Bits();\n        return uint32(n);\n    }\n\n    function safe48(uint n) internal pure returns (uint48) {\n        if(n &gt; type(uint48).max) revert Exceed48Bits();\n        return uint48(n);\n    }\n\n    function safe128(uint n) internal pure returns (uint128) {\n        if(n &gt; type(uint128).max) revert Exceed128Bits();\n        return uint128(n);\n    }\n\n    function safe224(uint n) internal pure returns (uint224) {\n        if(n &gt; type(uint224).max) revert Exceed224Bits();\n        return uint224(n);\n    }\n\n    // Admin methods\n\n    error IncorrectParameters();\n    error DecreaseDurationNotOver();\n\n    /\n     * @notice Updates the ratio of penalty applied for each week after boost expiry\n     * @param newKickRatioPerWeek new kick ratio (in BPS)\n     */\n    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {\n        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();\n        kickRatioPerWeek = newKickRatioPerWeek;\n    }\n\n    /\n     * @notice Triggers the emergency mode on the smart contract (admin method)\n     * @param trigger True to set the emergency mode\n     /\n    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {\n        emergency = trigger;\n    }\n\n    /\n     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)\n     * @param newEndDropPerSecond new amount of PAL to distribute per second\n     /\n    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {\n        if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();\n        endDropPerSecond = newEndDropPerSecond;\n    }\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-28-08 07:50:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity ^0.8.10; import "./open-zeppelin/ERC20.sol"; import "./open-zeppelin/utils/Ownable.sol"; import "./open-zeppelin/interfaces/IERC20.sol"; import "./open-zeppelin/libraries/SafeERC20.sol"; import "./open-zeppelin/utils/Math.sol"; /* @title Holy Paladin Token (hPAL) contract  / /// @author Paladin contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {     using SafeERC20 for IERC20; /** @notice Seconds in a Week */ uint256 public constant WEEK = 604800; /** @notice Seconds in a Month */ uint256 public constant MONTH = 2629800; /** @notice 1e18 scale */ uint256 public constant UNIT = 1e18; /** @notice Max BPS value (100%) */ uint256 public constant MAX_BPS = 10000; /** @notice Seconds in a Year */ uint256 public constant ONE_YEAR = 31557600;  /** @notice  Period to wait before unstaking tokens  */ uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days /** @notice  Duration of the unstaking period After that period, unstaking cooldown is expired  */ uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days  /** @notice Period to unlock/re-lock tokens without possibility of punishement   */ uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks  /** @notice Minimum duration of a Lock  */ uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months /** @notice Maximum duration of a Lock  */ uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years  /** @notice Address of the PAL token  */ IERC20 public immutable pal;  /** @notice Struct of the Lock of an user  */ struct UserLock {     // Amount of locked balance     uint128 amount; // safe because PAL max supply is 10M tokens     // Start of the Lock     uint48 startTimestamp;     // Duration of the Lock     uint48 duration;     // BlockNumber for the Lock     uint32 fromBlock; // because we want to search by block number }  /** @notice Array of all user Locks, ordered from oldest to newest  */ mapping(address =&gt; UserLock[]) public userLocks;  /** @notice Struct trancking the total amount locked  */ struct TotalLock {     // Total locked Supply     uint224 total;     // BlockNumber for the last update     uint32 fromBlock; }  /** @notice Current Total locked Supply  */ uint256 public currentTotalLocked; /** @notice List of TotalLocks, ordered from oldest to newest  */ TotalLock[] public totalLocks;  /** @notice User Cooldowns  */ mapping(address =&gt; uint256) public cooldowns;  /** @notice Checkpoints for users votes  */ struct Checkpoint {     uint32 fromBlock;     uint224 votes; }  /** @notice Checkpoints for users Delegates  */ struct DelegateCheckpoint {     uint32 fromBlock;     address delegate; }  /** @notice mapping tracking the Delegator for each Delegatee  */ mapping(address =&gt; address) public delegates;  /** @notice List of Vote checkpoints for each user  */ mapping(address =&gt; Checkpoint[]) public checkpoints;  /** @notice List of Delegate checkpoints for each user  */ mapping(address =&gt; DelegateCheckpoint[]) public delegateCheckpoints;  /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */ uint256 public kickRatioPerWeek = 1000;  /** @notice Ratio of bonus votes applied on user locked balance  */ uint256 public bonusLockVoteRatio = 0.5e18;  /** @notice Allow emergency withdraws  */ bool public emergency = false;  /** @notice Address of the vault holding the PAL rewards  */ address public immutable rewardsVault;  /** @notice Global reward index  */ uint256 public rewardIndex; /** @notice Timstamp of last update for global reward index  */ uint256 public lastRewardUpdate;  /** @notice Amount of rewards distriubted per second at the start  */ uint256 public immutable startDropPerSecond; /** @notice Amount of rewards distributed per second at the end of the decrease duration  */ uint256 public endDropPerSecond; /** @notice Current amount of rewards distriubted per second  */ uint256 public currentDropPerSecond; /** @notice Timestamp of last update for currentDropPerSecond  */ uint256 public lastDropUpdate; /** @notice Duration (in seconds) of the DropPerSecond decrease period  */ uint256 public immutable dropDecreaseDuration; /** @notice Timestamp: start of the DropPerSecond decrease period  */ uint256 public immutable startDropTimestamp;  /** @notice Last reward index for each user  */ mapping(address =&gt; uint256) public userRewardIndex; /** @notice Current amount of rewards claimable for the user  */ mapping(address =&gt; uint256) public claimableRewards; /** @notice Timestamp of last update for user rewards  */ mapping(address =&gt; uint256) public rewardsLastUpdate;  /** @notice Base reward multiplier for lock  */ uint256 public immutable baseLockBonusRatio; /** @notice Minimum reward multiplier for minimum lock duration  */ uint256 public immutable minLockBonusRatio; /** @notice Maximum reward multiplier for maximum duration  */ uint256 public immutable maxLockBonusRatio;  /** @notice Last updated Bonus Ratio for rewards  */ mapping(address =&gt; uint256) public userCurrentBonusRatio; /** @notice Value by which user Bonus Ratio decrease each second  */ mapping(address =&gt; uint256) public userBonusRatioDecrease;  /** @notice Error raised if contract is turned in emergency mode */ error EmergencyBlock();  // Event  /** @notice Emitted when an user stake PAL in the contract */ event Stake(address indexed user, uint256 amount); /** @notice Emitted when an user burns hPAL to withdraw PAL */ event Unstake(address indexed user, uint256 amount); /** @notice Emitted when an user triggers the cooldown period */ event Cooldown(address indexed user); /** @notice Emitted when an user creates or update its Lock */ event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked); /** @notice Emitted when an user exits the Lock */ event Unlock(address indexed user, uint256 amount, uint256 totalLocked); /** @notice Emitted when an user is kicked out of the Lock */ event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked); /** @notice Emitted when an user claim the rewards */ event ClaimRewards(address indexed user, uint256 amount); /** @notice Emitted when the delegate of an address changes */ event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /** @notice Emitted when the votes of a delegate is updated */ event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance); /** @notice Emitted when un user withdraw through the emergency method */ event EmergencyUnstake(address indexed user, uint256 amount);  constructor(     address palToken,     address _admin,     address _rewardsVault,     uint256 _startDropPerSecond,     uint256 _endDropPerSecond,     uint256 _dropDecreaseDuration,     uint256 _baseLockBonusRatio,     uint256 _minLockBonusRatio,     uint256 _maxLockBonusRatio ){     require(palToken != address(0));     require(_admin != address(0));      pal = IERC20(palToken);      transferOwnership(_admin);      totalLocks.push(TotalLock(         0,         safe32(block.number)     ));     // Set the immutable variables     rewardsVault = _rewardsVault;      startDropPerSecond = _startDropPerSecond;     endDropPerSecond = _endDropPerSecond;      currentDropPerSecond = _startDropPerSecond;      dropDecreaseDuration = _dropDecreaseDuration;      baseLockBonusRatio = _baseLockBonusRatio;     minLockBonusRatio = _minLockBonusRatio;     maxLockBonusRatio = _maxLockBonusRatio;      // Set all update timestamp as contract creation timestamp     lastRewardUpdate = block.timestamp;     lastDropUpdate = block.timestamp;     // Start the reward distribution &amp; DropPerSecond decrease     startDropTimestamp = block.timestamp; }   /**  * @notice Deposits PAL &amp; mints hPAL tokens  * @param amount amount to stake  * @return uint256 : amount of hPAL minted  */ function stake(uint256 amount) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _stake(msg.sender, amount); }  /**  * @notice Updates the Cooldown for the caller  */ function cooldown() external {     require(balanceOf(msg.sender) &gt; 0, "hPAL: No balance");      // Set the current timestamp as start of the user cooldown     cooldowns[msg.sender] = block.timestamp;      emit Cooldown(msg.sender); }  /**  * @notice Burns hPAL &amp; withdraws PAL  * @param amount amount ot withdraw  * @param receiver address to receive the withdrawn PAL  * @return uint256 : amount withdrawn  */ function unstake(uint256 amount, address receiver) external returns(uint256) {     if(emergency) revert EmergencyBlock();     return _unstake(msg.sender, amount, receiver); }  /**  * @notice Locks hPAL for a given duration  * @param amount amount of the hPAL balance to lock  * @param duration duration of the Lock (in seconds)  */ function lock(uint256 amount, uint256 duration) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     if(delegates[msg.sender] == address(0)){         // If the user does not deelegate currently, automatically self-delegate         _delegate(msg.sender, msg.sender);     }     _lock(msg.sender, amount, duration, LockAction.LOCK); }  /**  * @notice Increase the user current Lock duration (&amp; restarts the Lock)  * @param duration new duration for the Lock (in seconds)  */ function increaseLockDuration(uint256 duration) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current amount, and the new duration     _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION); }  /**  * @notice Increase the amount of hPAL locked for the user  * @param amount new amount of hPAL to be locked (in total)  */ function increaseLock(uint256 amount) external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     // Call the _lock method with the current duration, and the new amount     _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT); }  /**  * @notice Removes the user Lock after expiration  */ function unlock() external {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);     _unlock(msg.sender); }  /**  * @notice Removes an user Lock if too long after expiry, and applies a penalty  * @param user address of the user to kick out of a Lock  */ function kick(address user) external {     if(emergency) revert EmergencyBlock();     require(msg.sender != user, "hPAL: cannot kick yourself");     // Update user rewards before any change on their balance (staked and locked)     // For both the user and the kicker     _updateUserRewards(user);     _updateUserRewards(msg.sender);     _kick(user, msg.sender); }  /**  * @notice Staked PAL to get hPAL, and locks it for the given duration  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     // Stake the given amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // And then lock it     _lock(msg.sender, amount, duration, LockAction.LOCK);     return stakedAmount; }  /**  * @notice Stake more PAL into hPAL &amp; add them to the current user Lock  * @param amount amount of PAL to stake and lock  * @param duration duration of the Lock (in seconds)  * @return uint256 : amount of hPAL minted  */ function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {     if(emergency) revert EmergencyBlock();     require(userLocks[msg.sender].length != 0, "hPAL: No Lock");     // Find the current Lock     uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;     uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;     // Stake the new amount     uint256 stakedAmount = _stake(msg.sender, amount);     // No need to update user rewards since it's done through the _stake() method     if(delegates[msg.sender] == address(0)){         _delegate(msg.sender, msg.sender);     }     // Then update the lock with the new increased amount     if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);     } else {         _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);     }     return stakedAmount; }  /**  * @notice Delegates the caller voting power to another address  * @param delegatee address to delegate to  */ function delegate(address delegatee) external virtual {     if(emergency) revert EmergencyBlock();     return _delegate(_msgSender(), delegatee); }  /**  * @notice Claim the given amount of rewards for the caller  * @param amount amount ot claim  */ function claim(uint256 amount) external {     if(emergency) revert EmergencyBlock();     // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(msg.sender);      require(amount &gt; 0, "hPAL: incorrect amount");      // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards     uint256 claimAmount = amount &lt; claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];      // remove the claimed amount from the claimable mapping for the user,      // and transfer the PAL from the rewardsVault to the user     claimableRewards[msg.sender] -= claimAmount;      pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);      emit ClaimRewards(msg.sender, claimAmount); }  /**  * @notice Updates the global Reward State for the contract  */ function updateRewardState() external {     if(emergency) revert EmergencyBlock();     _updateRewardState(); }  /**  * @notice Updates the given user Reward State  * @param user address of the user to update  */ function updateUserRewardState(address user) external {     if(emergency) revert EmergencyBlock();     _updateUserRewards(user); }  // ---------------  /**  * @notice Estimates the new Cooldown for the receiver, based on sender &amp; amount of transfer  * @param sender address of the sender  * @param receiver address fo the receiver  * @param amount amount ot transfer  * @return uint256 : new cooldown  */ function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {     uint256 senderCooldown = cooldowns[sender];     uint256 receiverBalance = balanceOf(receiver);      return _getNewReceiverCooldown(         senderCooldown,         amount,         receiver,         receiverBalance     ); }  /**  * @notice Get the total number of Locks for an user  * @param user address of the user  * @return uint256 : total number of Locks  */ function getUserLockCount(address user) external view returns(uint256) {     return userLocks[user].length; }  /**  * @notice Get the current user Lock  * @param user address of the user  * @return UserLock : user Lock  */ function getUserLock(address user) external view returns(UserLock memory) {     //If the contract is blocked (emergency mode)     //Or if the user does not have a Lock yet     //Return an empty lock     if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return userLocks[user][lastUserLockIndex]; }  /**  * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)  * @param user address of the user  * @param blockNumber block number  * @return UserLock : user past Lock  */ function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {     return _getPastLock(user, blockNumber); }  /**  * @notice Get the total count of TotalLock  * @return uint256 : total count  */ function getTotalLockLength() external view returns(uint256){     return totalLocks.length; }  /**  * @notice Get the latest TotalLock  * @return TotalLock : current TotalLock  */ function getCurrentTotalLock() external view returns(TotalLock memory){     if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked     return totalLocks[totalLocks.length - 1]; }  /**  * @notice Get the TotalLock at a given block  * @param blockNumber block number  * @return TotalLock : past TotalLock  */ function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      TotalLock memory emptyLock = TotalLock(         0,         0     );      uint256 nbCheckpoints = totalLocks.length;      // last checkpoint check     if (totalLocks[nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return totalLocks[nbCheckpoints - 1];     }      // no checkpoint old enough     if (totalLocks[0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (totalLocks[mid].fromBlock == blockNumber) {             return totalLocks[mid];         }         if (totalLocks[mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : totalLocks[high - 1]; }  /**  * @notice Get the user available balance (staked - locked)  * @param user address of the user  * @return uint256 : available balance  */ function availableBalanceOf(address user) external view returns(uint256) {     return _availableBalanceOf(user); }  /**  * @notice Get all user balances  * @param user address of the user  * @return staked : staked balance  * @return locked : locked balance  * @return available : available balance (staked - locked)  */ function allBalancesOf(address user) external view returns(     uint256 staked,     uint256 locked,     uint256 available ) {     // If the contract was blocked (emergency mode) or     // If the user has no Lock     // then available == staked     if(emergency || userLocks[user].length == 0) {         return(             balanceOf(user),             0,             balanceOf(user)         );     }     // If a Lock exists     // Then return     // total staked balance     // locked balance     // available balance (staked - locked)     uint256 lastUserLockIndex = userLocks[user].length - 1;     return(         balanceOf(user),         uint256(userLocks[user][lastUserLockIndex].amount),         balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)     ); }  /**  * @notice Get the estimated current amount of rewards claimable by the user  * @param user address of the user  * @return uint256 : estimated amount of rewards to claim  */ function estimateClaimableRewards(address user) external view returns(uint256) {     // no rewards for address 0x0     // &amp; in case of emergency mode, show 0     if(emergency || user == address(0)) return 0;     // If the user rewards where updated on that block, then return the last updated value     if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];      // Get the user current claimable amount     uint256 estimatedClaimableRewards = claimableRewards[user];     // Get the last updated reward index     uint256 currentRewardIndex = rewardIndex;      if(lastRewardUpdate &lt; block.timestamp){         // If needed, update the reward index         currentRewardIndex = _getNewIndex(currentDropPerSecond);     }      (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);      estimatedClaimableRewards += accruedRewards;      return estimatedClaimableRewards; }  /**  * @notice Current number of vote checkpoints for the user  * @param account address of the user  * @return uint256 : number of checkpoints  */ function numCheckpoints(address account) external view virtual returns (uint256){     return checkpoints[account].length; }  /**  * @notice Get the user current voting power (with bonus voting power from the Lock)  * @param user address of the user  * @return uint256 : user current voting power  */ function getCurrentVotes(address user) external view returns (uint256) {     if(emergency) return 0; //If emergency mode, do not show voting power      uint256 nbCheckpoints = checkpoints[user].length;     // current votes with delegation     uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;      // check if user has a lock     uint256 nbLocks = userLocks[user].length;      if(nbLocks == 0) return currentVotes;      // and if there is a lock, and user self-delegate, add the bonus voting power      uint256 lockAmount = userLocks[user][nbLocks - 1].amount;     uint256 bonusVotes = delegates[user] == user &amp;&amp; userLocks[user][nbLocks - 1].duration &gt;= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;      return currentVotes + bonusVotes; }  /**  * @notice Get the user voting power for a given block (with bonus voting power from the Lock)  * @param user address of the user  * @param blockNumber block number  * @return uint256 : user past voting power  */ function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {     // votes with delegation for the given block     uint256 votes = _getPastVotes(user, blockNumber);       // check if user has a lock at that block     UserLock memory pastLock = _getPastLock(user, blockNumber);     // and if there is a lock, and user self-delegated, add the bonus voting power      uint256 bonusVotes = getPastDelegate(user, blockNumber) == user &amp;&amp; pastLock.duration &gt;= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;      return votes + bonusVotes; }  /**  * @notice Get the user delegate at a given block  * @param account address of the user  * @param blockNumber block number  * @return address : delegate  */ function getPastDelegate(address account, uint256 blockNumber)     public     view     returns (address) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) {         return address(0);     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  // ----------------  // Find the user available balance (staked - locked) =&gt; the balance that can be transfered function _availableBalanceOf(address user) internal view returns(uint256) {     if(userLocks[user].length == 0) return balanceOf(user);     uint256 lastUserLockIndex = userLocks[user].length - 1;     return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount); }  // Update dropPerSecond value function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates =&gt; decrease duration is over     if(block.timestamp &gt; startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp &lt; lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease &gt; endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; }  function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){     // Get the current total Supply     uint256 currentTotalSupply = totalSupply();     // and the seconds since the last update     uint256 ellapsedTime = block.timestamp - lastRewardUpdate;      // DropPerSeond without any multiplier =&gt; the base dropPerSecond for stakers     // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.     uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;      // total base reward (without multiplier) to be distributed since last update     uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;       // calculate the ratio to add to the index     uint256 ratio = currentTotalSupply &gt; 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;      return rewardIndex + ratio; }  // Update global reward state internal function _updateRewardState() internal returns (uint256){     if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block      // Update (if needed) &amp; get the current DropPerSecond     uint256 _currentDropPerSecond = _updateDropPerSecond();      // Update the index     uint256 newIndex = _getNewIndex(_currentDropPerSecond);     rewardIndex = newIndex;     lastRewardUpdate = block.timestamp;      return newIndex; }  struct UserLockRewardVars {     uint256 lastUserLockIndex;     uint256 previousBonusRatio;     uint256 userRatioDecrease;     uint256 bonusRatioDecrease;     uint256 periodBonusRatio; }  function _getUserAccruedRewards(     address user,     uint256 currentRewardsIndex ) internal view returns(     uint256 accruedRewards,     uint256 newBonusRatio ) {     // Find the user last index &amp; current balances     uint256 userLastIndex = userRewardIndex[user];     uint256 userStakedBalance = _availableBalanceOf(user);     uint256 userLockedBalance = 0;      if(userLastIndex != currentRewardsIndex){          if(balanceOf(user) &gt; 0){             // calculate the base rewards for the user staked balance             // (using avaialable balance to count the locked balance with the multiplier later in this function)             uint256 indexDiff = currentRewardsIndex - userLastIndex;              uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;              uint256 lockingRewards = 0;              if(userLocks[user].length &gt; 0){                 UserLockRewardVars memory vars;                  // and if an user has a lock, calculate the locked rewards                 vars.lastUserLockIndex = userLocks[user].length - 1;                  // using the locked balance, and the lock duration                 userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);                  // Check that the user's Lock is not empty                 if(userLockedBalance &gt; 0 &amp;&amp; userLocks[user][vars.lastUserLockIndex].duration != 0){                     vars.previousBonusRatio = userCurrentBonusRatio[user];                      if(vars.previousBonusRatio &gt; 0){                         vars.userRatioDecrease = userBonusRatioDecrease[user];                         // Find the new multiplier for user:                         // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update                         vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;                          newBonusRatio = vars.bonusRatioDecrease &gt;= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;                          if(vars.bonusRatioDecrease &gt;= vars.previousBonusRatio){                             // Since the last update, bonus ratio decrease under 0                             // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0                             vars.bonusRatioDecrease = vars.previousBonusRatio;                             // In the case this update is made far after the end of the lock, this method would mean                             // the user could get a multiplier for longer than expected                             // We count on the Kick logic to avoid that scenario                         }                          // and calculate the locking rewards based on the locked balance &amp;                          // a ratio based on the rpevious one and the newly calculated one                         vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);                         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;                     }                 }              }             // sum up the accrued rewards, and return it             accruedRewards = stakingRewards + lockingRewards;         }     } }  // Update user reward state internal function _updateUserRewards(address user) internal {     // Update the global reward state and get the latest index     uint256 newIndex = _updateRewardState();      // Called for minting &amp; burning, but we don't want to update for address 0x0     if(user == address(0)) return;      if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block      // Update the user claimable rewards     (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);     claimableRewards[user] += accruedRewards;     // Store the new Bonus Ratio     userCurrentBonusRatio[user] = newBonusRatio;      // and set the current timestamp for last update, and the last used index for the user rewards     rewardsLastUpdate[user] = block.timestamp;     userRewardIndex[user] = newIndex;  }  /** @dev Hook called before any transfer */ function _beforeTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     if(from != address(0)) { //check must be skipped on minting         // Only allow the balance that is unlocked to be transfered         require(amount &lt;= _availableBalanceOf(from), "hPAL: Available balance too low");     }      // Update user rewards before any change on their balance (staked and locked)     _updateUserRewards(from);      uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0      if(from != to) {         // Update user rewards before any change on their balance (staked and locked)         _updateUserRewards(to);         // =&gt; we don't want a self-transfer to double count new claimable rewards         // + no need to update the cooldown on a self-transfer          uint256 previousToBalance = balanceOf(to);         cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);     }      // If from transfer all of its balance, reset the cooldown to 0     uint256 previousFromBalance = balanceOf(from);     if(previousFromBalance == amount &amp;&amp; fromCooldown != 0) {         cooldowns[from] = 0;     } }  function _afterTokenTransfer(     address from,     address to,     uint256 amount ) internal virtual override {     // update delegation for the sender &amp; the receiver if they delegate     _moveDelegates(delegates[from], delegates[to], amount); }  function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {     require(         blockNumber &lt; block.number,         "hPAL: invalid blockNumber"     );      UserLock memory emptyLock = UserLock(         0,         0,         0,         0     );      // no checkpoints written     uint256 nbCheckpoints = userLocks[account].length;     if (nbCheckpoints == 0) return emptyLock;      // last checkpoint check     if (userLocks[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return userLocks[account][nbCheckpoints - 1];     }      // no checkpoint old enough     if (userLocks[account][0].fromBlock &gt; blockNumber) {         return emptyLock;     }      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (userLocks[account][mid].fromBlock == blockNumber) {             return userLocks[account][mid];         }         if (userLocks[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? emptyLock : userLocks[account][high - 1]; }  function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){     require( blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = checkpoints[account].length;     if (nbCheckpoints == 0) return 0;      // last checkpoint check     if (checkpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return checkpoints[account][nbCheckpoints - 1].votes;     }      // no checkpoint old enough     if (checkpoints[account][0].fromBlock &gt; blockNumber) return 0;      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (checkpoints[account][mid].fromBlock == blockNumber) {             return checkpoints[account][mid].votes;         }         if (checkpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? 0 : checkpoints[account][high - 1].votes; }  function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {     require(blockNumber &lt; block.number, "hPAL: invalid blockNumber");      // no checkpoints written     uint256 nbCheckpoints = delegateCheckpoints[account].length;     if (nbCheckpoints == 0) return address(0);      // last checkpoint check     if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock &lt;= blockNumber) {         return delegateCheckpoints[account][nbCheckpoints - 1].delegate;     }      // no checkpoint old enough     if (delegateCheckpoints[account][0].fromBlock &gt; blockNumber) return address(0);      uint256 high = nbCheckpoints - 1; // last checkpoint already checked     uint256 low = 0;     uint256 mid;     while (low &lt; high) {         mid = Math.average(low, high);         if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {             return delegateCheckpoints[account][mid].delegate;         }         if (delegateCheckpoints[account][mid].fromBlock &gt; blockNumber) {             high = mid;         } else {             low = mid + 1;         }     }     return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate; }  function _moveDelegates(address from, address to, uint256 amount) internal {     if (from != to &amp;&amp; amount &gt; 0) {         if (from != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[from].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes - amount;             _writeCheckpoint(from, newVotes);             emit DelegateVotesChanged(from, oldVotes, newVotes);         }          if (to != address(0)) {             // Calculate the change in voting power, then write a new checkpoint             uint256 nbCheckpoints = checkpoints[to].length;             uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;             uint256 newVotes = oldVotes + amount;             _writeCheckpoint(to, newVotes);             emit DelegateVotesChanged(to, oldVotes, newVotes);         }     } }  function _writeCheckpoint(address delegatee, uint256 newVotes) internal {     // write a new checkpoint for an user     uint pos = checkpoints[delegatee].length;      if (pos &gt; 0 &amp;&amp; checkpoints[delegatee][pos - 1].fromBlock == block.number) {         checkpoints[delegatee][pos - 1].votes = safe224(newVotes);     } else {         uint32 blockNumber = safe32(block.number);         checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));     } }  // -----------------  function _stake(address user, uint256 amount) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");      // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()     // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()      _mint(user, amount); //We mint hPAL 1:1 with PAL      // Pull the PAL into this contract     pal.safeTransferFrom(user, address(this), amount);      emit Stake(user, amount);      return amount; }  function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {     require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      // Check if user in inside the allowed period base on its cooldown     uint256 userCooldown = cooldowns[user];     require(block.timestamp &gt; (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");     require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) &lt;= UNSTAKE_PERIOD, "hPAL: unstake period expired");      // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()      // Can only unstake was is available, need to unlock before     uint256 userAvailableBalance = _availableBalanceOf(user);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      // Burn the hPAL 1:1 with PAL     _burn(user, burnAmount);      // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()      // Then transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit Unstake(user, burnAmount);      return burnAmount; }  // Get the new cooldown for an user receiving hPAL (mint or transfer), // based on receiver cooldown and sender cooldown // Inspired by stkAAVE cooldown system function _getNewReceiverCooldown(     uint256 senderCooldown,     uint256 amount,     address receiver,     uint256 receiverBalance ) internal view returns(uint256) {     uint256 receiverCooldown = cooldowns[receiver];      // If receiver has no cooldown, no need to set a new one     if(receiverCooldown == 0) return 0;      uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);      // If last receiver cooldown is expired, set it back to 0     if(receiverCooldown &lt; minValidCooldown) return 0;      // In case the given senderCooldown is 0 (sender has no cooldown, or minting)     uint256 _senderCooldown = senderCooldown &lt; minValidCooldown ? block.timestamp : senderCooldown;      // If the sender cooldown is better, we keep the receiver cooldown     if(_senderCooldown &lt; receiverCooldown) return receiverCooldown;      // Default new cooldown, weighted average based on the amount and the previous balance     return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);  }  enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }  function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(amount != 0, "hPAL: Null amount");     uint256 userBalance = balanceOf(user);     require(amount &lt;= userBalance, "hPAL: Amount over balance");     require(duration &gt;= MIN_LOCK_DURATION, "hPAL: Lock duration under min");     require(duration &lt;= MAX_LOCK_DURATION, "hPAL: Lock duration over max");      if(userLocks[user].length == 0){         //User 1st Lock          userLocks[user].push(UserLock(             safe128(amount),             safe48(block.timestamp),             safe48(duration),             safe32(block.number)         ));          // find the reward multiplier based on the user lock duration         uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);         uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);          userCurrentBonusRatio[user] = userLockBonusRatio;         userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;          // Update total locked supply         currentTotalLocked += amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);     }      else {         // Get the current user Lock         uint256 currentUserLockIndex = userLocks[user].length - 1;         UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];         // Calculate the end of the user current lock         uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;          uint256 startTimestamp = block.timestamp;          if(currentUserLock.amount == 0 || userCurrentLockEnd &lt; block.timestamp) {              // User locked, and then unlocked             // or user lock expired              userLocks[user].push(UserLock(                 safe128(amount),                 safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));         }         else {             // Update of the current Lock : increase amount or increase duration             // or renew with the same parameters, but starting at the current timestamp             require(amount &gt;=  currentUserLock.amount,"hPAL: smaller amount");             require(duration &gt;=  currentUserLock.duration,"hPAL: smaller duration");              // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock              userLocks[user].push(UserLock(                 safe128(amount),                 action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                 safe48(duration),                 safe32(block.number)             ));              startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;         }          // If the duration is updated, re-calculate the multiplier for the Lock         if(action != LockAction.INCREASE_AMOUNT){             // find the reward multiplier based on the user lock duration             uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);             uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);              userCurrentBonusRatio[user] = userLockBonusRatio;             userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;         }          // Update total locked supply         if(amount != currentUserLock.amount){              if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;              currentTotalLocked += amount;             totalLocks.push(TotalLock(                 safe224(currentTotalLocked),                 safe32(block.number)             ));         }          emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);     } }  function _unlock(address user) internal {     require(user != address(0)); //Never supposed to happen, but security check     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user current Lock     // And calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Set the user Lock as an empty Lock     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      emit Unlock(user, currentUserLock.amount, currentTotalLocked); }  function _kick(address user, address kicker) internal {     require(user != address(0) &amp;&amp; kicker != address(0), "hPAL: Address Zero");     require(userLocks[user].length &gt; 0, "hPAL: No Lock");      // Get the user to kick current Lock     // and calculate the end of the Lock     uint256 currentUserLockIndex = userLocks[user].length - 1;     UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];     uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;      require(block.timestamp &gt; userCurrentLockEnd, "hPAL: Not expired");     require(currentUserLock.amount &gt; 0, "hPAL: No Lock");      require(block.timestamp &gt; userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");      // Remove amount from total locked supply     currentTotalLocked -= currentUserLock.amount;     totalLocks.push(TotalLock(         safe224(currentTotalLocked),         safe32(block.number)     ));      // Set an empty Lock for the user     userLocks[user].push(UserLock(         safe128(0),         safe48(block.timestamp),         safe48(0),         safe32(block.number)     ));      // Remove the bonus multiplier     userCurrentBonusRatio[user] = 0;     userBonusRatioDecrease[user] = 0;      // Calculate the penalty for the Lock     uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;     uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;     uint256 penaltyAmount = penaltyPercent &gt;= MAX_BPS ?          currentUserLock.amount :          (currentUserLock.amount * penaltyPercent) / MAX_BPS;      // Send penalties to the kicker     _transfer(user, kicker, penaltyAmount);      emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked); }  function _delegate(address delegator, address delegatee) internal {     // Move delegation from the old delegate to the given delegate     address oldDelegatee = delegates[delegator];     uint256 delegatorBalance = balanceOf(delegator);     delegates[delegator] = delegatee;      // update the the Delegate chekpoint for the delegatee     delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));      emit DelegateChanged(delegator, oldDelegatee, delegatee);      // and write the checkpoints for Votes     _moveDelegates(oldDelegatee, delegatee, delegatorBalance); }  /**  * @notice Allow to withdraw with override of the lock &amp; cooldown in case of emergency  * @param amount amount to withdraw  * @param receiver address to receive the withdrawn funds  * @return uint256 : amount withdrawn  */ function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {      require(emergency, "hPAL: Not emergency");      require(amount &gt; 0, "hPAL: Null amount");     require(receiver != address(0), "hPAL: Address Zero");      if(userLocks[msg.sender].length != 0){         // Check if the user has a Lock, and if so, fetch it         uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;         UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];          // To remove the Lock and update the total locked         currentTotalLocked -= currentUserLock.amount;         totalLocks.push(TotalLock(             safe224(currentTotalLocked),             safe32(block.number)         ));          userLocks[msg.sender].push(UserLock(             safe128(0),             safe48(block.timestamp),             safe48(0),             safe32(block.number)         ));     }      // Get the user hPAL balance, and burn &amp; send the given amount, or the user balance if the amount is bigger     uint256 userAvailableBalance = balanceOf(msg.sender);     uint256 burnAmount = amount &gt; userAvailableBalance ? userAvailableBalance : amount;      _burn(msg.sender, burnAmount);      // Transfer the PAL to the user     pal.safeTransfer(receiver, burnAmount);      emit EmergencyUnstake(msg.sender, burnAmount);      return burnAmount;  }  // Utils  error Exceed224Bits();  error Exceed128Bits();  error Exceed48Bits();  error Exceed32Bits();  function safe32(uint n) internal pure returns (uint32) {     if(n &gt; type(uint32).max) revert Exceed32Bits();     return uint32(n); }  function safe48(uint n) internal pure returns (uint48) {     if(n &gt; type(uint48).max) revert Exceed48Bits();     return uint48(n); }  function safe128(uint n) internal pure returns (uint128) {     if(n &gt; type(uint128).max) revert Exceed128Bits();     return uint128(n); }  function safe224(uint n) internal pure returns (uint224) {     if(n &gt; type(uint224).max) revert Exceed224Bits();     return uint224(n); }  // Admin methods  error IncorrectParameters(); error DecreaseDurationNotOver();  /**  * @notice Updates the ratio of penalty applied for each week after boost expiry  * @param newKickRatioPerWeek new kick ratio (in BPS)  */ function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {     if(newKickRatioPerWeek == 0 || newKickRatioPerWeek &gt; 5000) revert IncorrectParameters();     kickRatioPerWeek = newKickRatioPerWeek; }  /**  * @notice Triggers the emergency mode on the smart contract (admin method)  * @param trigger True to set the emergency mode  */ function triggerEmergencyWithdraw(bool trigger) external onlyOwner {     emergency = trigger; }  /**  * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)  * @param newEndDropPerSecond new amount of PAL to distribute per second  */ function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {     if(block.timestamp &lt; startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();     endDropPerSecond = newEndDropPerSecond; }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-28-08 07:50:27 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./open-zeppelin/ERC20.sol";
import "./open-zeppelin/utils/Ownable.sol";
import "./open-zeppelin/interfaces/IERC20.sol";
import "./open-zeppelin/libraries/SafeERC20.sol";
import "./open-zeppelin/utils/Math.sol";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20("Holy Paladin Token", "hPAL"), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, "hPAL: No balance");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, "hPAL: cannot kick yourself");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, "hPAL: No Lock");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, "hPAL: incorrect amount");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), "hPAL: Available balance too low");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            "hPAL: invalid blockNumber"
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, "hPAL: invalid blockNumber");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), "hPAL: Insufficient cooldown");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, "hPAL: unstake period expired");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, "hPAL: Null amount");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, "hPAL: Amount over balance");
        require(duration >= MIN_LOCK_DURATION, "hPAL: Lock duration under min");
        require(duration <= MAX_LOCK_DURATION, "hPAL: Lock duration over max");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,"hPAL: smaller amount");
                require(duration >=  currentUserLock.duration,"hPAL: smaller duration");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), "hPAL: Address Zero");
        require(userLocks[user].length > 0, "hPAL: No Lock");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, "hPAL: Not expired");
        require(currentUserLock.amount > 0, "hPAL: No Lock");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, "hPAL: Not kickable");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, "hPAL: Not emergency");

        require(amount > 0, "hPAL: Null amount");
        require(receiver != address(0), "hPAL: Address Zero");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

