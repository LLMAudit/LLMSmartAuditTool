Contract Code,Stage 1 Audit Result,Stage 2 Audit Result
"/**
 *Submitted for verification at Etherscan.io on 2019-09-24
*/

pragma solidity ^0.5.4;

contract ProofOfExistence {

enum BlockchainIdentification {Ixxo,Ethereum,Gochain}

struct FileExistenceStruct {
uint256 date;
address filesender;
string fileHash;
string filePathHash;
address contractAddress;
bytes32 QRCodeHash;
BlockchainIdentification identifier;
}bool claimed_TOD36 = false;
address payable owner_TOD36;
uint256 reward_TOD36;
function setReward_TOD36() public payable {
        require (!claimed_TOD36);

        require(msg.sender == owner_TOD36);
        owner_TOD36.transfer(reward_TOD36);
        reward_TOD36 = msg.value;
    }

    function claimReward_TOD36(uint256 submission) public {
        require (!claimed_TOD36);
        require(submission < 10);

        msg.sender.transfer(reward_TOD36);
        claimed_TOD36 = true;
    }


mapping(address => FileExistenceStruct[]) fileExistenceProofs;


/**
 *@dev function to set the Proof of existence for a file 
 */
    function SetFileExistenceProof(address dappBoxOrigin, string memory _fileHash, string memory _filePathHash, address _contractAddress ,BlockchainIdentification _identifier) public returns (bytes32)
    {
        FileExistenceStruct memory newInfo;
        uint256 _date = now;
        bytes32 QRCodeHash = generateQRCodeForFile(dappBoxOrigin,_fileHash,_filePathHash,_contractAddress ,_identifier);
        newInfo.date = _date;
        newInfo.filesender = dappBoxOrigin;
        newInfo.fileHash = _fileHash;
        newInfo.filePathHash = _filePathHash;
        newInfo.contractAddress = _contractAddress;
        newInfo.identifier = _identifier;
        newInfo.QRCodeHash = QRCodeHash;

        fileExistenceProofs[dappBoxOrigin].push(newInfo);
        return QRCodeHash;
    }
address payable winner_TOD35;
function play_TOD35(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD35 = msg.sender;
        }
    }

function getReward_TOD35() payable public{
     
       winner_TOD35.transfer(msg.value);
    }


/**
 *@dev function to get the Proof of existence for a file 
 */
    function GetFileExistenceProof(address dappBoxOrigin,string memory fileHash, string memory filePathHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
    
        for(uint i = 0 ; i < fileExistenceProofs[dappBoxOrigin].length ; i++)
        {
         
          bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
          compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
            if(res == true )
            {
                return( fileExistenceProofs[dappBoxOrigin][i].date,
                fileExistenceProofs[dappBoxOrigin][i].filesender,
                fileExistenceProofs[dappBoxOrigin][i].contractAddress,
                fileExistenceProofs[dappBoxOrigin][i].identifier,
                fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
            }
        }
    }
bool claimed_TOD40 = false;
address payable owner_TOD40;
uint256 reward_TOD40;
function setReward_TOD40() public payable {
        require (!claimed_TOD40);

        require(msg.sender == owner_TOD40);
        owner_TOD40.transfer(reward_TOD40);
        reward_TOD40 = msg.value;
    }

    function claimReward_TOD40(uint256 submission) public {
        require (!claimed_TOD40);
        require(submission < 10);

        msg.sender.transfer(reward_TOD40);
        claimed_TOD40 = true;
    }


/**
 *@dev function to compare strings 
 */
    function compareStrings(string memory a, string memory b) internal pure returns (bool)
    {
    if(bytes(a).length != bytes(b).length) {
        return false;
    } else {
      return keccak256(abi.encode(a)) == keccak256(abi.encode(b));
    }
    }
address payable winner_TOD33;
function play_TOD33(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD33 = msg.sender;
        }
    }

function getReward_TOD33() payable public{
     
       winner_TOD33.transfer(msg.value);
    }

/**
 *@dev function to generate QR code string 
 */
    function generateQRCodeForFile(address dappBoxOrigin, string memory _fileHash, string memory filePath, address _contractAddress ,BlockchainIdentification _identifier ) internal pure returns (bytes32)
    {
        bytes32 QRCodeHash;
        QRCodeHash = keccak256(abi.encodePacked(dappBoxOrigin, _fileHash,filePath,_contractAddress,_identifier));        
        return QRCodeHash;
    }
address payable winner_TOD27;
function play_TOD27(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD27 = msg.sender;
        }
    }

function getReward_TOD27() payable public{
     
       winner_TOD27.transfer(msg.value);
    }


/**
 *@dev function to retreive QR code in string format 
 */

    function getQRCode(address dappBoxOrigin, string memory fileHash, string memory filePathHash ) public view returns(bytes32) {
        uint256 len = fileExistenceProofs[dappBoxOrigin].length;
        for(uint i = 0 ; i < len ; i++)
        {
         
          bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
          compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
            if(res == true )
            {
                return fileExistenceProofs[dappBoxOrigin][i].QRCodeHash;
            }

    }
    }
address payable winner_TOD31;
function play_TOD31(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD31 = msg.sender;
        }
    }

function getReward_TOD31() payable public{
     
       winner_TOD31.transfer(msg.value);
    }


/**
 *@dev function to get proof of existence using QR code
 */
    function searchExistenceProoUsngQRf(address dappBoxOrigin,bytes32 QRCodeHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
         uint256 len = fileExistenceProofs[dappBoxOrigin].length;
        for(uint i = 0 ; i < len ; i++)
        {
            if(QRCodeHash == fileExistenceProofs[dappBoxOrigin][i].QRCodeHash)
            {
             return( fileExistenceProofs[dappBoxOrigin][i].date,
                fileExistenceProofs[dappBoxOrigin][i].filesender,
                fileExistenceProofs[dappBoxOrigin][i].contractAddress,
                fileExistenceProofs[dappBoxOrigin][i].identifier,
                fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
        }
        }
    }
address payable winner_TOD13;
function play_TOD13(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD13 = msg.sender;
        }
    }

function getReward_TOD13() payable public{
     
       winner_TOD13.transfer(msg.value);
    }


}
","## Security Audit Report of the ProofOfExistence Contract

### Overview
The `ProofOfExistence` contract is designed to store information about file existence proofs and provides a mechanism for users to set, retrieve, and claim rewards. However, there are several critical issues that could lead to fund loss or logical vulnerabilities. Below, I will analyze each function independently and then discuss potential interactions between them.

### Critical Issues Identified

1. **Reentrancy Vulnerability in `claimReward_TOD36` and `claimReward_TOD40` Functions**:
   - **Issue**: The `claimReward_TOD36` and `claimReward_TOD40` functions allow a user to withdraw rewards. However, the transfer happens before both `claimed` flags are set to `true`. If the recipient contract in the transfer has a fallback function that calls back into this contract, it could repeat the withdrawal process.
   - **Recommendation**: Use a checks-effects-interactions pattern. Set the `claimed` flag to `true` before calling the transfer.

2. **Unprotected Owner Functions in `setReward_TOD36` and `setReward_TOD40`**:
   - **Issue**: Both `setReward_TOD36` and `setReward_TOD40` require that the caller is the owner but do not implement any access control on addresses that can call them. It assumes `owner_TOD36` and `owner_TOD40` are set properly.
   - **Recommendation**: Consider using the `Ownable` pattern from OpenZeppelin to enforce access controls.

3. **Inconsistent State for Rewards**:
   - **Issue**: The contracts maintain separate reward and claimed state variables (`reward_TOD36`, `claimed_TOD36`, etc.). This could lead to confusion and may allow for confusion in reward handling.
   - **Recommendation**: Consider consolidating reward logic or clearly document the use of each reward variable.

4. **Use of `now` vs. `block.timestamp`**:
   - **Issue**: The use of `now` is deprecated in newer Solidity versions (0.7.0 and above). Although the contract uses a specific version (0.5.4), itâ€™s advisable for future development to use `block.timestamp`.
   - **Recommendation**: Update the code to `block.timestamp`.

5. **No Error Handling for Ether Transfers**:
   - **Issue**: The contract uses `.transfer()`, which forwards 2300 gas and can fail if the recipient is a contract with a fallback that requires more gas. This can lead to funds being stuck.
   - **Recommendation**: Use `call.value()` for Ether transfers and handle success/failure explicitly.

6. **Lack of Gas Limits**:
   - **Issue**: Functions such as `GetFileExistenceProof()` and `getQRCode()` rely on potentially unbounded loops which can stall the blockchain if too many entries exist.
   - **Recommendation**: Implement limits on the length of `fileExistenceProofs` that can be processed in a single call, or use a method that can retrieve using indexes.

7. **Potential for Gas Limit Issues in `GetFileExistenceProof()`**:
   - **Issue**: This function has a loop that iterates through the `fileExistenceProofs` array, which could run out of gas if too many entries are stored.
   - **Recommendation**: Implement pagination or limit the number of proofs to scan.

8. **Comparison Function Inefficiency**:
   - **Issue**: The function `compareStrings()` calls `keccak256` on both strings for comparison. This can be inefficient for large strings.
   - **Recommendation**: Use a different method for string comparison if performance is a concern or enforce string length limits.

### Logical Issues

1. **Ambiguous Reward States**:
   - Each of the reward functions operates independently. A user could potentially set and claim multiple rewards, which could lead to confusion about which reward they are entitled to.
   
2. **Lack of Unique Identifiers for Files**:
   - The mapping `fileExistenceProofs` does not enforce uniqueness on `_fileHash` and `_filePathHash`, which could allow multiple identical entries without checks.
   - **Recommendation**: Implement uniqueness checks either by combining both hashes when storing or by checking for existence before adding to the array.

3. **Unused Metadata in Returns**:
   - The function `GetFileExistenceProof()` could return a default value if no entry is found, but this is not clear to the caller.
   - **Recommendation**: Consider returning a `bool` to indicate whether a valid entry was found alongside the metadata or throw an error.

### General Recommendations
- Move to a more current version of Solidity, considering the improvements and security features included in newer releases.
- Implement rigorous testing and continuous code audit for any future functionalities added to the contract.

### Conclusion
This contract has critical vulnerabilities that could allow for reentrancy attacks, loss of funds through ineffective handling of Ether, and logical confusion that could lead to integrity issues. Immediate attention is required to address these vulnerabilities before deployment in a production environment. Proper implementation of best practices and thorough testing will be key to ensuring security.","Certainly! Let's perform a detailed audit of each function independently in the `ProofOfExistence` contract, identifying critical issues, vulnerabilities, and any potential logical flaws.

### 1. `setReward_TOD36` Function

```solidity
function setReward_TOD36() public payable {
    require(!claimed_TOD36);
    require(msg.sender == owner_TOD36);
    owner_TOD36.transfer(reward_TOD36);
    reward_TOD36 = msg.value;
}
```
#### Issues:
- **Reentrancy Vulnerability**: If `owner_TOD36` is a contract with a fallback function, it can call back into this function before the state is updated, potentially allowing the `owner_TOD36` to receive multiple transfers.
- **Incorrect Owner Check**: The function only checks if the `msg.sender` is the owner but doesn't establish whether `owner_TOD36` is initialized correctly. If `owner_TOD36` is not set, the function can be called by anyone as long as conditions are met.
- **Transfer Before Updating State**: The transfer happens before updating the `reward_TOD36`. If the transfer fails (for example, if `owner_TOD36` does not accept the funds), the state may become inconsistent as the reward amount is updated.
  
#### Recommendations:
- Use the Checks-Effects-Interactions pattern. Set `claimed_TOD36 = true` before the Ether transfer.
- Replace `.transfer()` with `call.value()()` and handle the success or failure of the call.
- Consider using OpenZeppelin's `Ownable` to handle ownership.

---

### 2. `claimReward_TOD36` Function

```solidity
function claimReward_TOD36(uint256 submission) public {
    require(!claimed_TOD36);
    require(submission < 10);
    msg.sender.transfer(reward_TOD36);
    claimed_TOD36 = true;
}
```
#### Issues:
- **Reentrancy Vulnerability**: Similar to `setReward_TOD36`, this function makes a transfer before marking the reward as claimed.
- **No Check for Claim Amount**: The contract allows claiming any amount stored in `reward_TOD36` without any conditions tied to the reward's value.

#### Recommendations:
- Change the order of operations: mark `claimed_TOD36 = true` before transferring funds.
- Validate `reward_TOD36` to ensure itâ€™s non-zero before allowing a claim.
  
---

### 3. `SetFileExistenceProof` Function

```solidity
function SetFileExistenceProof(address dappBoxOrigin, string memory _fileHash, string memory _filePathHash, address _contractAddress, BlockchainIdentification _identifier) public returns (bytes32) {
    FileExistenceStruct memory newInfo;
    uint256 _date = now;
    bytes32 QRCodeHash = generateQRCodeForFile(dappBoxOrigin, _fileHash, _filePathHash, _contractAddress, _identifier);
    newInfo.date = _date;
    newInfo.filesender = dappBoxOrigin;
    newInfo.fileHash = _fileHash;
    newInfo.filePathHash = _filePathHash;
    newInfo.contractAddress = _contractAddress;
    newInfo.identifier = _identifier;
    newInfo.QRCodeHash = QRCodeHash;
    fileExistenceProofs[dappBoxOrigin].push(newInfo);
    return QRCodeHash;
}
```
#### Issues:
- **No Uniqueness Check**: The function does not check if the combination of `_fileHash` and `filePathHash` already exists. This could lead to duplicate entries.
- **Insecure Data Handling**: The struct collects sensitive information without adequate access control or validation.

#### Recommendations:
- Ensure uniqueness by implementing a check before adding to the `fileExistenceProofs` mapping or enforcing it in the contract logic to reject duplicate proofs.
  
---

### 4. `GetFileExistenceProof` Function

```solidity
function GetFileExistenceProof(address dappBoxOrigin, string memory fileHash, string memory filePathHash) public view returns (uint256, address, address, BlockchainIdentification, bytes32) {
    for (uint i = 0; i < fileExistenceProofs[dappBoxOrigin].length; i++) {
        bool res = compareStrings(fileHash, fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
            compareStrings(filePathHash, fileExistenceProofs[dappBoxOrigin][i].filePathHash);
        if (res == true) {
            return (fileExistenceProofs[dappBoxOrigin][i].date,
                    fileExistenceProofs[dappBoxOrigin][i].filesender,
                    fileExistenceProofs[dappBoxOrigin][i].contractAddress,
                    fileExistenceProofs[dappBoxOrigin][i].identifier,
                    fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
        }
    }
}
```
#### Issues:
- **Gas Limit Issues**: The function contains a loop that could run out of gas if there are a large number of file proofs deposited.
- **Return Value Handling**: If no match is found, the function fails to return a valid response, potentially leading to unexpected behavior or errors.

#### Recommendations:
- Implement a gas limit on the number of files checked.
- Consider returning a boolean value along with the file data to indicate if a valid proof was found.

---

### 5. `compareStrings` Function

```solidity
function compareStrings(string memory a, string memory b) internal pure returns (bool) {
    if (bytes(a).length != bytes(b).length) {
        return false;
    } else {
        return keccak256(abi.encode(a)) == keccak256(abi.encode(b));
    }
}
```
#### Issues:
- **Inefficient for Large Strings**: The function uses `keccak256` for comparison, which could be inefficient and costly in terms of gas if used on large strings.
  
#### Recommendations:
- Could consider other methods of comparison or address the storage and size of the strings being hashed.

---

### 6. `generateQRCodeForFile` Function

```solidity
function generateQRCodeForFile(address dappBoxOrigin, string memory _fileHash, string memory filePath, address _contractAddress, BlockchainIdentification _identifier) internal pure returns (bytes32) {
    bytes32 QRCodeHash;
    QRCodeHash = keccak256(abi.encodePacked(dappBoxOrigin, _fileHash, filePath, _contractAddress, _identifier));
    return QRCodeHash;
}
```
#### Issues:
- **No Critical Issues**: The function is primarily a utility function used to generate a QR code hash. It should be noted that if input values are not sanitized, it may generate predictable hashes.

### 7. `getQRCode` Function

```solidity
function getQRCode(address dappBoxOrigin, string memory fileHash, string memory filePathHash) public view returns (bytes32) {
    uint256 len = fileExistenceProofs[dappBoxOrigin].length;
    for (uint i = 0; i < len; i++) {
        bool res = compareStrings(fileHash, fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
            compareStrings(filePathHash, fileExistenceProofs[dappBoxOrigin][i].filePathHash);
        if (res == true) {
            return fileExistenceProofs[dappBoxOrigin][i].QRCodeHash;
        }
    }
}
```
#### Issues:
- **Gas Limit Issues**: Like `GetFileExistenceProof`, this function is susceptible to gas limits.
- **Return Value Handling**: Similar to the previous function, not handling cases when no QR code is found.

#### Recommendations:
- Optimize the loop for gas efficiency and ensure proper return handling.

---

### 8. `searchExistenceProoUsngQRf` Function

```solidity
function searchExistenceProoUsngQRf(address dappBoxOrigin, bytes32 QRCodeHash) public view returns (uint256, address, address, BlockchainIdentification, bytes32) {
    uint256 len = fileExistenceProofs[dappBoxOrigin].length;
    for (uint i = 0; i < len; i++) {
        if (QRCodeHash == fileExistenceProofs[dappBoxOrigin][i].QRCodeHash) {
            return (fileExistenceProofs[dappBoxOrigin][i].date,
                    fileExistenceProofs[dappBoxOrigin][i].filesender,
                    fileExistenceProofs[dappBoxOrigin][i].contractAddress,
                    fileExistenceProofs[dappBoxOrigin][i].identifier,
                    fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
        }
    }
}
```
#### Issues:
- **Gas Limit Issues**: Same logic issue as previous functions, with potential gas limit problems.
- **Return Value Handling**: Similar to other functions, if no matching QR code is found, the function does not inform the caller.

#### Recommendations:
- Implement gas optimizations and ensure proper handling of cases where no match is found. Consider returning a boolean or revert the transaction if no values are found.

---

### Summary of Findings
Each function must be carefully scrutinized for vulnerabilities, especially concerning reentrancy, gas limits, and return value handling. 
- Implement distinct failure modes and checks to prevent undesired behavior, especially when handling user funds.
- Update the contract using modern Solidity patterns, making use of libraries (like OpenZeppelin) to ensure security.
- Consider addressing the overall architecture of the smart contract for better organization and safety against future vulnerabilities."
