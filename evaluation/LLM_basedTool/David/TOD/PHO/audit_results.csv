Contract Code,Stage 1 Audit Result,Stage 2 Audit Result
"/**
 * Source Code first verified at https://etherscan.io on Tuesday, May 7, 2019
 */

pragma solidity ^0.5.11;


/**
 * @title PHO token - for Game coin sale
 * @author Willy Lee
 */


/**
 * @title ERC20 Standard Interface
 */
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}


/**
 * @title Token implementation
 */
contract PHO is IERC20 {
  bool claimed_TOD26 = false;
address payable owner_TOD26;
uint256 reward_TOD26;
function setReward_TOD26() public payable {
        require (!claimed_TOD26);

        require(msg.sender == owner_TOD26);
        owner_TOD26.transfer(reward_TOD26);
        reward_TOD26 = msg.value;
    }

    function claimReward_TOD26(uint256 submission) public {
        require (!claimed_TOD26);
        require(submission < 10);

        msg.sender.transfer(reward_TOD26);
        claimed_TOD26 = true;
    }
  string public name = ""PHO"";
  bool claimed_TOD20 = false;
address payable owner_TOD20;
uint256 reward_TOD20;
function setReward_TOD20() public payable {
        require (!claimed_TOD20);

        require(msg.sender == owner_TOD20);
        owner_TOD20.transfer(reward_TOD20);
        reward_TOD20 = msg.value;
    }

    function claimReward_TOD20(uint256 submission) public {
        require (!claimed_TOD20);
        require(submission < 10);

        msg.sender.transfer(reward_TOD20);
        claimed_TOD20 = true;
    }
  string public symbol = ""PHO"";
  bool claimed_TOD32 = false;
address payable owner_TOD32;
uint256 reward_TOD32;
function setReward_TOD32() public payable {
        require (!claimed_TOD32);

        require(msg.sender == owner_TOD32);
        owner_TOD32.transfer(reward_TOD32);
        reward_TOD32 = msg.value;
    }

    function claimReward_TOD32(uint256 submission) public {
        require (!claimed_TOD32);
        require(submission < 10);

        msg.sender.transfer(reward_TOD32);
        claimed_TOD32 = true;
    }
  uint8 public decimals = 18;
    
  bool claimed_TOD38 = false;
address payable owner_TOD38;
uint256 reward_TOD38;
function setReward_TOD38() public payable {
        require (!claimed_TOD38);

        require(msg.sender == owner_TOD38);
        owner_TOD38.transfer(reward_TOD38);
        reward_TOD38 = msg.value;
    }

    function claimReward_TOD38(uint256 submission) public {
        require (!claimed_TOD38);
        require(submission < 10);

        msg.sender.transfer(reward_TOD38);
        claimed_TOD38 = true;
    }
  uint256 saleAmount;
  bool claimed_TOD4 = false;
address payable owner_TOD4;
uint256 reward_TOD4;
function setReward_TOD4() public payable {
        require (!claimed_TOD4);

        require(msg.sender == owner_TOD4);
        owner_TOD4.transfer(reward_TOD4);
        reward_TOD4 = msg.value;
    }

    function claimReward_TOD4(uint256 submission) public {
        require (!claimed_TOD4);
        require(submission < 10);

        msg.sender.transfer(reward_TOD4);
        claimed_TOD4 = true;
    }
  uint256 evtAmount;
  address payable winner_TOD7;
function play_TOD7(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD7 = msg.sender;
        }
    }

function getReward_TOD7() payable public{
     
       winner_TOD7.transfer(msg.value);
    }
  uint256 teamAmount;

  address payable winner_TOD23;
function play_TOD23(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD23 = msg.sender;
        }
    }

function getReward_TOD23() payable public{
     
       winner_TOD23.transfer(msg.value);
    }
  uint256 _totalSupply;
  bool claimed_TOD14 = false;
address payable owner_TOD14;
uint256 reward_TOD14;
function setReward_TOD14() public payable {
        require (!claimed_TOD14);

        require(msg.sender == owner_TOD14);
        owner_TOD14.transfer(reward_TOD14);
        reward_TOD14 = msg.value;
    }

    function claimReward_TOD14(uint256 submission) public {
        require (!claimed_TOD14);
        require(submission < 10);

        msg.sender.transfer(reward_TOD14);
        claimed_TOD14 = true;
    }
  mapping(address => uint256) balances;

  bool claimed_TOD30 = false;
address payable owner_TOD30;
uint256 reward_TOD30;
function setReward_TOD30() public payable {
        require (!claimed_TOD30);

        require(msg.sender == owner_TOD30);
        owner_TOD30.transfer(reward_TOD30);
        reward_TOD30 = msg.value;
    }

    function claimReward_TOD30(uint256 submission) public {
        require (!claimed_TOD30);
        require(submission < 10);

        msg.sender.transfer(reward_TOD30);
        claimed_TOD30 = true;
    }
  address public owner;
  bool claimed_TOD8 = false;
address payable owner_TOD8;
uint256 reward_TOD8;
function setReward_TOD8() public payable {
        require (!claimed_TOD8);

        require(msg.sender == owner_TOD8);
        owner_TOD8.transfer(reward_TOD8);
        reward_TOD8 = msg.value;
    }

    function claimReward_TOD8(uint256 submission) public {
        require (!claimed_TOD8);
        require(submission < 10);

        msg.sender.transfer(reward_TOD8);
        claimed_TOD8 = true;
    }
  address public sale;
  address payable winner_TOD39;
function play_TOD39(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD39 = msg.sender;
        }
    }

function getReward_TOD39() payable public{
     
       winner_TOD39.transfer(msg.value);
    }
  address public evt;
  bool claimed_TOD36 = false;
address payable owner_TOD36;
uint256 reward_TOD36;
function setReward_TOD36() public payable {
        require (!claimed_TOD36);

        require(msg.sender == owner_TOD36);
        owner_TOD36.transfer(reward_TOD36);
        reward_TOD36 = msg.value;
    }

    function claimReward_TOD36(uint256 submission) public {
        require (!claimed_TOD36);
        require(submission < 10);

        msg.sender.transfer(reward_TOD36);
        claimed_TOD36 = true;
    }
  address public team;
    
    modifier isOwner {
        require(owner == msg.sender);
        _;
    }
    
    constructor() public {
        owner   = msg.sender;
        sale    = 0x071F73f4D0befd4406901AACE6D5FFD6D297c561;
        evt     = 0x76535ca5BF1d33434A302e5A464Df433BB1F80F6;
        team    = 0xD7EC5D8697e4c83Dc33D781d19dc2910fB165D5C;

        saleAmount    = toWei(1000000000);  
        //1,000,000,000
        evtAmount     = toWei(200000000);   
        //  200,000,000
        teamAmount    = toWei(800000000);   
        //  800,000,000
        _totalSupply  = toWei(2000000000);  
        //2,000,000,000

        require(_totalSupply == saleAmount + evtAmount + teamAmount );
        
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, balances[owner]);
        
        transfer(sale, saleAmount);
        transfer(evt, evtAmount);
        transfer(team, teamAmount);
        require(balances[owner] == 0);
    }
address payable winner_TOD35;
function play_TOD35(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD35 = msg.sender;
        }
    }

function getReward_TOD35() payable public{
     
       winner_TOD35.transfer(msg.value);
    }
    
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }
bool claimed_TOD40 = false;
address payable owner_TOD40;
uint256 reward_TOD40;
function setReward_TOD40() public payable {
        require (!claimed_TOD40);

        require(msg.sender == owner_TOD40);
        owner_TOD40.transfer(reward_TOD40);
        reward_TOD40 = msg.value;
    }

    function claimReward_TOD40(uint256 submission) public {
        require (!claimed_TOD40);
        require(submission < 10);

        msg.sender.transfer(reward_TOD40);
        claimed_TOD40 = true;
    }

    function balanceOf(address who) public view returns (uint256) {
        return balances[who];
    }
address payable winner_TOD33;
function play_TOD33(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD33 = msg.sender;
        }
    }

function getReward_TOD33() payable public{
     
       winner_TOD33.transfer(msg.value);
    }
    
    function transfer(address to, uint256 value) public returns (bool success) {
        require(msg.sender != to);
        require(value > 0);
        
        require( balances[msg.sender] >= value );
        require( balances[to] + value >= balances[to] );

        if(msg.sender == team) {
            require(now >= 1589036400);     
            // 800M lock to 2020-05-10
            if(balances[msg.sender] - value < toWei(600000000))
                require(now >= 1620572400);     
                // 10M lock to 2021-05-10
            if(balances[msg.sender] - value < toWei(400000000))
                require(now >= 1652108400);     
                // 10M lock to 2022-05-10
            if(balances[msg.sender] - value < toWei(200000000))
                require(now >= 1683644400);     
                // 10M lock to 2023-05-10
        }

        balances[msg.sender] -= value;
        balances[to] += value;

        emit Transfer(msg.sender, to, value);
        return true;
    }
address payable winner_TOD27;
function play_TOD27(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD27 = msg.sender;
        }
    }

function getReward_TOD27() payable public{
     
       winner_TOD27.transfer(msg.value);
    }
    
    function burnCoins(uint256 value) public {
        require(balances[msg.sender] >= value);
        require(_totalSupply >= value);
        
        balances[msg.sender] -= value;
        _totalSupply -= value;

        emit Transfer(msg.sender, address(0), value);
    }
address payable winner_TOD31;
function play_TOD31(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD31 = msg.sender;
        }
    }

function getReward_TOD31() payable public{
     
       winner_TOD31.transfer(msg.value);
    }


    /** @dev private function
     */

    function toWei(uint256 value) private view returns (uint256) {
        return value * (10 ** uint256(decimals));
    }
address payable winner_TOD13;
function play_TOD13(bytes32 guess) public{
 
       if (keccak256(abi.encode(guess)) == keccak256(abi.encode('hello'))) {

            winner_TOD13 = msg.sender;
        }
    }

function getReward_TOD13() payable public{
     
       winner_TOD13.transfer(msg.value);
    }
}","The provided contract implements a basic ERC20 token called the PHO token, but it contains multiple issues that could lead to loss of funds or unintended behavior. Below is a detailed audit of the code, focusing on each function independently and highlighting critical security issues, especially logic-related vulnerabilities:

### Contract Audit Overview

The audit will cover the following aspects for each function:
1. **Function Modifiers & Access Control**
2. **Logic Flaws**
3. **Reentrancy Vulnerabilities**
4. **Integer Overflow/Underflow**
5. **Gas Limit and Loops**
6. **Fund Management and Withdrawal Issues**

### Auditor's Findings

#### Constructor

1. **Hardcoded Addresses**:
   - The sale, evt, and team addresses are hardcoded. If any of these are malicious or have issues, it can affect all token holders. Consider using an external trusted source or governance model for setting these addresses.

2. **Total Supply Validation**:
   - The constructor checks if the `_totalSupply` equals the sum of the three initialized amounts. While this validates the total supply during deployment, it does not prevent tampering with the values unless you have locked or immutable variables defined.

3. **Immediate Token Transfer**:
   - The contract transfers tokens immediately to other addresses. If any of these transactions fail, the user's expectation of balance can be incorrect. Use proper checks after transfer operations.

#### `totalSupply`

- This function appears to be fine as it merely returns the `_totalSupply`.

#### `balanceOf`

- This function is also safe, working as expected by returning the balance of the address passed as an argument.

#### `transfer`

1. **Lack of Reentrancy Guard**:
   - The transfer function should implement a reentrancy guard (using ReentrancyGuard pattern) to prevent reentrancy attacks if the recipient is a smart contract.

2. **Timestamp-based Locks**:
   - The implementation relies on timestamps (e.g., `now >= 1589036400`) for unlocking balances. Thus, this type of locking mechanism can lead to confusion and potential misuse. Additionally, someone could potentially front-run the unlock window by executing transactions just before they become valid.

3. **Overflows and Underflows**:
   - While Solidity 0.5 provides built-in overflow and underflow checks with the latest versions, itâ€™s better to explicitly unit test the balances to ensure accurate representation after transfers. 

4. **Gas Limit Restrictions**:
   - Not directly impacting funds per se, but ensure that functions are optimized for gas; the transfer function should be checked against gas limits if many tokens are transferred in a single transaction.

#### `burnCoins`

1. **Improper Value Checks**:
   - It checks against both the `_totalSupply` and the balance of the sender. However, every burn should trigger an event to log what amount was burned, which is missing here. 

2. **No Emit for Transfer Event**:
   - While an event is emitted for the transfer to the zero address, it should also log the burn amount for proper tracing.

#### Reward Functions (`setReward_TOD*` and `claimReward_TOD*`)

1. **Ownership Logic**:
   - These functions rely on a single owner for executing reward claims. If the private key to the owner's address is compromised, the contract could lose funds through these functions. Implement a multi-signature wallet for better security.

2. **Lack of Event Emission**:
   - Reward functions should emit events for better tracking and auditing.

3. **Replay Vulnerability**:
   - Since these are independent for different rewards, the state does not track the changes properly, leading to potential funds being reused or mismanaged.

#### `toWei`

- The function does not have vulnerabilities, but ensure that it does not run arbitrary calculations with untyped input that can lead to unexpected behavior.

### Conclusion

The PHO contract has numerous logical and security issues, particularly in its handling of fund transfers and access controls. Here are key recommendations:

1. **Implement Access Control**: For sensitive functions, use modifiers and role-check mechanisms (e.g., Ownable from OpenZeppelin).
2. **Add Reentrancy Protection**: Use a `nonReentrant` pattern for functions dealing with ether transfers.
3. **Remove Hardcoded Values**: Avoid hardcoded addresses, allowing for flexibility and a governance approach.
4. **Event Emission**: Emit relevant events for better visibility into critical contract state changes.
5. **Update Solidity Version**: If possible, move to the latest Solidity version (0.8.x) which includes built-in arithmetic safety checks.
6. **Test Thoroughly**: Create extensive unit tests to cover various attack vectors.

Overall, addressing the highlighted issues can significantly enhance the security and reliability of the PHO token smart contract.","Certainly! I'll go through the contract function by function, analyzing each independently for potential vulnerabilities and issues. Here's the detailed evaluation:

### 1. Constructor
```solidity
constructor() public {
    owner   = msg.sender;
    ...
    require(_totalSupply == saleAmount + evtAmount + teamAmount );
    
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, balances[owner]);
    
    transfer(sale, saleAmount);
    transfer(evt, evtAmount);
    transfer(team, teamAmount);
    require(balances[owner] == 0);
}
```
**Issues:**
- **Hardcoded Addresses**: The addresses for the sale, evt, and team are hardcoded, which could lead to loss of tokens if set to the wrong addresses or compromised addresses.
- **Immediate Transfer**: The constructor transfers tokens to other addresses right away. If any of these transfers fail, it does not revert the constructor execution and can lead to inconsistent token holdings.
- **Initialization Validation**: The constructor checks that the total supply matches the individual allocations. However, if changes need to be made later, this could restrict flexibility.

### 2. `totalSupply`
```solidity
function totalSupply() public view returns (uint) {
    return _totalSupply;
}
```
**Issues:**
- No issues found. This function simply returns the total supply and does not modify state.

### 3. `balanceOf`
```solidity
function balanceOf(address who) public view returns (uint256) {
    return balances[who];
}
```
**Issues:**
- No issues found. This function also merely returns the balance of the specified address.

### 4. `transfer`
```solidity
function transfer(address to, uint256 value) public returns (bool success) {
    require(msg.sender != to);
    require(value > 0);
    require(balances[msg.sender] >= value);
    require(balances[to] + value >= balances[to]);

    if(msg.sender == team) {
        ...
    }

    balances[msg.sender] -= value;
    balances[to] += value;

    emit Transfer(msg.sender, to, value);
    return true;
}
```
**Issues:**
- **Reentrancy Vulnerability**: If the `to` address is a contract, it could potentially call back into the `transfer` function, causing unexpected behavior. Consider implementing a reentrancy guard.
- **Timestamp-based Locks**: The `if (msg.sender == team)` logic relies on timestamps for token transfers. These hardcoded timestamps can create confusion and mismanagement of funds. Additionally, reliance on `now` (deprecated in later versions of Solidity; should use `block.timestamp`).
- **Integer Overflow**: Although Solidity 0.5 has built-in checks, ensure that the amount being transferred and the balance management truly prevent any overflow/underflow scenarios (currently there are checks in place).

### 5. `burnCoins`
```solidity
function burnCoins(uint256 value) public {
    require(balances[msg.sender] >= value);
    require(_totalSupply >= value);
    
    balances[msg.sender] -= value;
    _totalSupply -= value;

    emit Transfer(msg.sender, address(0), value);
}
```
**Issues:**
- **Improper Overdraft Checks**: The `require(_totalSupply >= value)` line is not entirely necessary since burning from user's balance already limits this scenario.
- **Event Emission**: Although it emits a Transfer event to the `address(0)`, it should also functionally support logging the burn (consider adding a distinct `Burn` event for clarity).
- **Lack of Checks on Overflow/Underflow**: As with transfers, ensure that with the modifications occurring, there cannot be overflow/underflow.

### 6. Reward Functions (`setReward_TOD*` and `claimReward_TOD*`)
```solidity
function setReward_TOD26() public payable {
    require (!claimed_TOD26);
    require(msg.sender == owner_TOD26);
    owner_TOD26.transfer(reward_TOD26);
    reward_TOD26 = msg.value;
}

// Similar for the other `setReward_TOD*` functions...

function claimReward_TOD26(uint256 submission) public {
    require (!claimed_TOD26);
    require(submission < 10);
    msg.sender.transfer(reward_TOD26);
    claimed_TOD26 = true;
}
```
**Issues:**
- **Single Owner Vulnerability**: These functions are only callable by a single `owner_TOD*`. If the owner's private key is compromised, funds could be manipulated or stolen.
- **Potential for Funds Lost**: If `msg.value` is sent during the `setReward_TOD*` calls but those functions are called after the data has been set, funds could be lost or accumulate improperly.
- **Replay Attack**: Designing each reward function as independent may lead to unintended consequences if not tracked properly. Funds could potentially be claimed multiple times by simple manipulation of `submission` values.

### 7. `toWei`
```solidity
function toWei(uint256 value) private view returns (uint256) {
    return value * (10 ** uint256(decimals));
}
```
**Issues:**
- No issues identified in isolation, but the function should be validated for proper input management and overall use within the contract.

### Summary of Findings:
The primary issues within the contract stem from:
1. **Function Logic**: Certain functions have logical mishaps, primarily in controls (reentrancy potential) and in time-based limitations.
2. **Access Control**: Only one owner for several critical functions poses a single point of failure.
3. **Event Emission**: Some important actions are lack adequate event logging, making tracking difficult.
4. **Hardcoded Addresses and Values**: These should in general be avoided unless adequately vetted through a governance process.

### Recommendations:
1. Implement **reentrancy protection** for any function that transfers Ether or tokens.
2. Remove hardcoded addresses or implement a way to set them through governance.
3. Introduce **event logging** for critical actions, especially around token burns and transfers.
4. Finalize the logic for **ownership** to introduce multi-signature controls or an owner transfer mechanism.

This detailed examination of each function highlights the potential vulnerabilities and issues within the contract that could lead to loss of funds or unintended behavior.
"
