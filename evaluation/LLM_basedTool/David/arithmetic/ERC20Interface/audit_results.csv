Contract Code,Stage 1 Audit Result,Stage 2 Audit Result
"/**
 *Submitted for verification at Etherscan.io on 2019-09-22
 * 13 integer overflow/underflow in the contract
 * underflow: 7, overflow: 6
*/

pragma solidity ^0.5.11;

// * Gods Unchained Raffle Token Exchange
//
// * Version 1.0
//
// * A dedicated contract for listing (selling) and buying raffle tokens.
//
// * https://gu.cards

contract ERC20Interface {
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
function bug_intou7() public pure{
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
}

contract IERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
function bug_intou23() public pure{
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
    function balanceOf(address account) external view returns (uint256);
mapping(address => uint) balances_intou14;

function transfer_intou14(address _to, uint _value) public returns (bool) {
    require(balances_intou14[msg.sender] - _value >= 0);  
    //bug
    balances_intou14[msg.sender] -= _value;  
    //bug
    balances_intou14[_to] += _value;  
    //bug
    return true;
  }
}

contract RaffleToken is ERC20Interface, IERC20Interface {}

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""SafeMath: modulo by zero"");
        return a % b;
    }
}

contract RaffleTokenExchange {
    using SafeMath for uint256;

    //////// V A R I A B L E S
    //
    // The raffle token contract
    //
    RaffleToken constant public raffleContract = RaffleToken(0x0C8cDC16973E88FAb31DD0FCB844DdF0e1056dE2);
    //
    // In case the exchange is paused.
    //
  function bug_intou19() public pure{
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
  bool public paused;
    //
    // Standard contract ownership.
    //
  mapping(address => uint) balances_intou26;

function transfer_intou26(address _to, uint _value) public returns (bool) {
    require(balances_intou26[msg.sender] - _value >= 0);  
    //bug
    balances_intou26[msg.sender] -= _value;  
    //bug
    balances_intou26[_to] += _value;  
    //bug
    return true;
  }
  address payable public owner;
    //
    // Next id for the next listing
    //
  function bug_intou20(uint8 p_intou20) public pure{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou20;   
    // overflow bug
}
  uint256 public nextListingId;
    //
    // All raffle token listings mapped by id
    //
  function bug_intou32(uint8 p_intou32) public pure{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou32;   
    // overflow bug
}
  mapping (uint256 => Listing) public listingsById;
    //
    // All purchases
    //
  mapping(address => uint) balances_intou38;

function transfer_intou38(address _to, uint _value) public returns (bool) {
    require(balances_intou38[msg.sender] - _value >= 0);  
    //bug
    balances_intou38[msg.sender] -= _value;  
    //bug
    balances_intou38[_to] += _value;  
    //bug
    return true;
  }
  mapping (uint256 => Purchase) public purchasesById;
    //
    // Next id for the next purche
    //
  function bug_intou4(uint8 p_intou4) public pure{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou4;   
    // overflow bug
}
  uint256 public nextPurchaseId;

    //////// S T R U C T S
    //
    //  A listing of raffle tokens
    //
    struct Listing {
        //
        // price per token (in wei).
        //
        uint256 pricePerToken;
        //
        //
        // How many tokens? (Original Amount)
        //
        uint256 initialAmount;
        //
        // How many tokens left? (Maybe altered due to partial sales)
        //
        uint256 amountLeft;
        //
        // Listed by whom?
        //
        address payable seller;
        //
        // Active/Inactive listing?
        //
        bool active;
    }
    //
    //  A purchase of raffle tokens
    //
    struct Purchase {
        //
        // How many tokens?
        //
        uint256 totalAmount;
        //
        // total price payed
        //
        uint256 totalAmountPayed;
        //
        // When did the purchase happen?
        //
        uint256 timestamp;
    }

    //////// EVENTS
    //
    //
    //
  function bug_intou27() public pure{
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
  event Listed(uint256 id, uint256 pricePerToken, uint256 initialAmount, address seller);
  function bug_intou31() public pure{
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
  event Canceled(uint256 id);
  mapping(address => uint) public lockTime_intou13;

function increaseLockTime_intou13(uint _secondsToIncrease) public {
        lockTime_intou13[msg.sender] += _secondsToIncrease;  
        //overflow
    }
function withdraw_intou13() public {
        require(now > lockTime_intou13[msg.sender]);    
        uint transferValue_intou13 = 10;           
        msg.sender.transfer(transferValue_intou13);
    }
  event Purchased(uint256 id, uint256 totalAmount, uint256 totalAmountPayed, uint256 timestamp);

    //////// M O D I F I E R S
    //
    // Invokable only by contract owner.
    //
    modifier onlyContractOwner {
        require(msg.sender == owner, ""Function called by non-owner."");
        _;
    }
    //
    // Invokable only if exchange is not paused.
    //
    modifier onlyUnpaused {
        require(paused == false, ""Exchange is paused."");
        _;
    }

    //////// C O N S T R U C T O R
    //
    constructor() public {
        owner = msg.sender;
        nextListingId = 916;
        nextPurchaseId = 344;
    }
mapping(address => uint) balances_intou30;

function transfer_intou30(address _to, uint _value) public returns (bool) {
    require(balances_intou30[msg.sender] - _value >= 0);  
    //bug
    balances_intou30[msg.sender] -= _value;  
    //bug
    balances_intou30[_to] += _value;  
    //bug
    return true;
  }

    //////// F U N C T I O N S
    //
    // buyRaffle
    //
    function buyRaffle(uint256[] calldata amounts, uint256[] calldata listingIds) payable external onlyUnpaused {
        require(amounts.length == listingIds.length, ""You have to provide amounts for every single listing!"");
        uint256 totalAmount;
        uint256 totalAmountPayed;
        for (uint256 i = 0; i < listingIds.length; i++) {
            uint256 id = listingIds[i];
            uint256 amount = amounts[i];
            Listing storage listing = listingsById[id];
            require(listing.active, ""Listing is not active anymore!"");
            listing.amountLeft = listing.amountLeft.sub(amount);
            require(listing.amountLeft >= 0, ""Amount left needs to be higher than 0."");
            if(listing.amountLeft == 0) { listing.active = false; }
            uint256 amountToPay = listing.pricePerToken * amount;
            listing.seller.transfer(amountToPay);
            totalAmountPayed = totalAmountPayed.add(amountToPay);
            totalAmount = totalAmount.add(amount);
            require(raffleContract.transferFrom(listing.seller, msg.sender, amount), 'Token transfer failed!');
        }
        require(totalAmountPayed <= msg.value, 'Overpayed!');
        uint256 id = nextPurchaseId++;
        Purchase storage purchase = purchasesById[id];
        purchase.totalAmount = totalAmount;
        purchase.totalAmountPayed = totalAmountPayed;
        purchase.timestamp = now;
        emit Purchased(id, totalAmount, totalAmountPayed, now);
    }
function bug_intou8(uint8 p_intou8) public pure{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou8;   
    // overflow bug
}
    //
    // Add listing
    //
    function addListing(uint256 initialAmount, uint256 pricePerToken) external onlyUnpaused {
        require(raffleContract.balanceOf(msg.sender) >= initialAmount, ""Amount to sell is higher than balance!"");
        require(raffleContract.allowance(msg.sender, address(this)) >= initialAmount, ""Allowance is to small (increase allowance)!"");
        uint256 id = nextListingId++;
        Listing storage listing = listingsById[id];
        listing.initialAmount = initialAmount;
        listing.amountLeft = initialAmount;
        listing.pricePerToken = pricePerToken;
        listing.seller = msg.sender;
        listing.active = true;
        emit Listed(id, listing.pricePerToken, listing.initialAmount, listing.seller);
    }
function bug_intou39() public pure{
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
    //
    // Cancel listing
    //
    function cancelListing(uint256 id) external {
        Listing storage listing = listingsById[id];
        require(listing.active, ""This listing was turned inactive already!"");
        require(listing.seller == msg.sender || owner == msg.sender, ""Only the listing owner or the contract owner can cancel the listing!"");
        listing.active = false;
        emit Canceled(id);
    }
function bug_intou36(uint8 p_intou36) public pure{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou36;   
    // overflow bug
}
    //
    // Set paused
    //
    function setPaused(bool value) external onlyContractOwner {
        paused = value;
    }
function bug_intou35() public pure{ 
    uint8 vundflw =0;
    vundflw = vundflw -10;   
    // underflow bug
}
    //
    // Funds withdrawal to cover operational costs
    //
    function withdrawFunds(uint256 withdrawAmount) external onlyContractOwner {
        owner.transfer(withdrawAmount);
    }
function bug_intou40(uint8 p_intou40) public pure{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou40;   
    // overflow bug
}
    //
    // Contract may be destroyed only when there is nothing else going on. 
    // All funds are transferred to contract owner.
    //
    function kill() external onlyContractOwner {
        selfdestruct(owner);
    }
mapping(address => uint) public lockTime_intou33;

function increaseLockTime_intou33(uint _secondsToIncrease) public {
        lockTime_intou33[msg.sender] += _secondsToIncrease;  
        //overflow
    }
function withdraw_intou33() public {
        require(now > lockTime_intou33[msg.sender]);    
        uint transferValue_intou33 = 10;           
        msg.sender.transfer(transferValue_intou33);
    }
}
","The contract presented contains multiple issues that can lead to potential vulnerabilities, especially around arithmetic operations, logic errors, and security measures. Below is a critical security audit of its functions, along with identified issues:

### **1. Integer Overflow/Underflow**:
- **General Issue**: The entire contract is written in Solidity 0.5.11, which does not include built-in overflow protection (introduced from version 0.8.x onwards). Any arithmetic operation (addition, subtraction, multiplication) is susceptible to overflow and underflow attacks.
- **Specific Functions**: The `sub` and `add` functions in the contract do not utilize the SafeMath library, leaving room for vulnerabilities when handling user balances and amounts in listings.

### **2. Risk of Funds Loss**:
- **Function `buyRaffle(uint256[] calldata amounts, uint256[] calldata listingIds)`**:
  - Logic Error: The check for how many tokens the buyer is attempting to purchase does not validate whether the requested amount can be fulfilled. If any of the amounts exceed `listing.amountLeft`, it will lead to a subsequent check that ensures `amountLeft` does not fall below zero, which could use uninitialized or outdated values.
  - **Race Condition**: By allowing `listing.amountLeft` to be updated after calculating `amountToPay`, malicious users could exploit the gap between the two operations to manipulate the state, leading to an argument where a user buys more than is available.
  - **Transfer Immediately**: If the token transfer fails after the seller has been paid, this would lead to both parties losing the respective amounts since there were no safety checks or reverts for such failures.

### **3. Listing Management**:
- **Function `addListing(uint256 initialAmount, uint256 pricePerToken)`**:
  - Lack of checks for minimum price: A malicious actor could list at a price of 0 (zero), which could disrupt the market.
- **Function `cancelListing(uint256 id)`**:
  - No mechanism for reactivation or time-locking listings canceled. This may prevent legitimate users or listings from being reactivated or reused properly.
  - Given the ownership checks, it is also possible for the owner to cancel any listing, leading to potential gas wars or front-run opportunities from malicious actors.

### **4. Withdrawals and Contract Functions**:
- **Function `withdrawFunds(uint256 withdrawAmount)`**:
  - Lack of proper checks and balances on the amount requested for withdrawal. If an attacker knows the owner address, they could potentially exploit this by triggering multiple withdrawal conditions or front-running withdraw requests.

### **5. Kill Function**:
- **Function `kill()`**:
  - Security concern with self-destruct. Any attacker with malicious intent could find a way to exploit the contract logic or race conditions, leaving them the opportunity to destroy the contract and withdraw user funds.

### **6. Event Logging**:
- The logging mechanisms lack a complete picture of actions taken. Integrating logging for significant state changes (such as amount left for a listing after a purchase) could aid in tracking malicious behaviors.

### **7. Pause Mechanism**:
- Using a boolean for the paused state is insufficient. When operating in environments with multiple contracts or systems, there should be a fallback or another mechanism to ensure that the pause state applies universally with clear transition pathways.

### **8. Other Miscellaneous Issues**:
- **ERC20 Interface Implementation**: The implementation of the `ERC20Interface` is not complete, as it does not have other critical functions such as `transfer()`, `approve()`, and `transferFrom()` method fully defined.
- **Lock Time Functionality**: The lock time management functions demonstrate timing vulnerabilities. If a locked user calls it multiple times, it would give the wrong notion of security and potentially lock them out longer than expected.

### **Conclusion**:
This contract requires critical refactoring and must adopt more modern practices when it comes to managing token exchanges, arithmetic checks, and security features. Using SafeMath correctly in all arithmetic operations, as well as implementing proper checks on function calls, can help mitigate several vulnerabilities highlighted in the audit. If the intention is to deploy this contract in a live setting, a comprehensive rewrite and additional security measures would be essential.","Certainly! Let's analyze each function in the contract independently, highlighting critical issues that can lead to loss of funds, vulnerabilities, or logic errors.

### **1. `buyRaffle(uint256[] calldata amounts, uint256[] calldata listingIds)`**

#### Issues:
- **Array Length Check**: The requirement checks that `amounts.length` matches `listingIds.length`, but it does not validate the values in those arrays. An improperly sized array can lead to out-of-bounds access, potentially fetching uninitialized `listing` objects.
- **Active Listing Check**: The check for `listing.active` happens after attempting to decrement `amountLeft`, which can cause state mutations even for inactive listings if checks happen late.
- **Decrementing `amountLeft`**: The function directly modifies `amountLeft` before confirming that the listing is able to fulfill the amount requested. If `amountLeft` is less than the requested `amount`, a negative state could occur, leading to issues on the subsequent calculations.
- **Payment Handling**: The seller is immediately transferred the `amountToPay` without checking if the transfer is successful. If the transfer fails, the state is already altered (like reducing `amountLeft`).
- **Overpayment Check**: The check for `totalAmountPayed` against `msg.value` occurs at the end. If the transactions earlier fail or revert, it might not be possible to handle funds correctly.

### **2. `addListing(uint256 initialAmount, uint256 pricePerToken)`**

#### Issues:
- **Balance and Allowance Checks**: Requires that the seller has sufficient balance and allowance for their tokens. However, not checking for cases where `initialAmount` is 0 may allow creating a listing with no tokens.
- **Price of 0**: There is no restriction on setting the `pricePerToken` to 0, which could allow a listing to be created that essentially causes a free minting of tokens.
- **State Changes**: There’s the risk that if the function fails after state changes, the contract might be left in a corrupted state (partially added listing).

### **3. `cancelListing(uint256 id)`**

#### Issues:
- **Active Check**: It checks if a listing is already inactive but does not handle situations where two different parties might try to change the listing state. A race condition can exist here.
- **Authority Check**: The owner or seller can cancel the listing, but without a proper tracking mechanism, this could lead to confusion if not logged completely.
- **No Reversal Mechanism**: Once a listing is canceled, it cannot be reactivated, which could potentially harm genuine sellers or listings that need revisiting.

### **4. `setPaused(bool value)`**

#### Issues:
- **Owner Control**: Only the contract owner can pause the contract. If the owner is compromised or malicious, they could halt all trading, censor transactions, or dictate terms unfairly.
- **No Conditions for Resuming**: Once set to paused, there are no conditions that facilitate reopening without external intervention, which could significantly affect usability.

### **5. `withdrawFunds(uint256 withdrawAmount)`**

#### Issues:
- **Unprotected Withdrawals**: There is no check ensuring that the contract has enough balance to cover the withdrawal. An attacker could deplete the contract by continually withdrawing large amounts or manipulating the state to attain unexpected amounts.
- **No Fallback Functions**: If the contract runs out of funds (particularly if tokens are not sold or management of user funds fails), the owner could lock funds indefinitely.

### **6. `kill()`**

#### Issues:
- **Destruction of Contract**: Only the owner can destroy the contract, which could be exploited if the owner behaves maliciously. They could also destroy the contract while transactions are still pending, potentially locking user funds.
- **External Calls on Self-Destruct**: If not properly coded, calling `selfdestruct(owner)` at the wrong time could lead to the loss of state and funds associated with active transactions.

### **7. Other Functions (General Issues)**

#### Issues:
- **SafeMath Implementation**: While it’s included, many arithmetic operations throughout the contract are unprotected. It is critical to ensure that every mathematical operation invokes the SafeMath methods to avoid overflow/underflow issues.
- **Event Logging**: While there are events such as `Listed`, `Canceled`, and `Purchased`, situations that involve significant state changes often lack comprehensive logs to help diagnose issues in the future.
- **Lack of Emergency Mechanisms**: The absence of multi-sig wallets or emergency stop patterns makes the contract vulnerable to failure modes.

### **Conclusion**

Each function in the contract has unique vulnerabilities and issues, suggesting that a significant overhaul is required to ensure security, robustness, and functionality. The incorporation of modern development practices (like open-source libraries) and comprehensive unit testing, alongside frequent code reviews, must be considered essential as part of the contract's development lifecycle."
