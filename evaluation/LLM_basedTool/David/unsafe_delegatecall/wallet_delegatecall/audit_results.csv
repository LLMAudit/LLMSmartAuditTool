Contract Code,Stage 1 Audit Result,Stage 2 Audit Result
"pragma solidity ^0.4.9;

contract WalletEvents {
  event Confirmation(address owner, bytes32 operation);
  event Revoke(address owner, bytes32 operation);

  // some others are in the case of an owner changing.
  event OwnerChanged(address oldOwner, address newOwner);
  event OwnerAdded(address newOwner);
  event OwnerRemoved(address oldOwner);

  // the last one is emitted if the required signatures change
  event RequirementChanged(uint newRequirement);

  // Funds has arrived into the wallet (record how much).
  event Deposit(address _from, uint value);
  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).
  event SingleTransact(address owner, uint value, address to, bytes data, address created);
  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).
  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);
  // Confirmation still needed for a transaction.
  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
}

contract WalletAbi {
  // Revokes a prior confirmation of the given operation
  function revoke(bytes32 _operation) external;

  // Replaces an owner `_from` with another `_to`.
  function changeOwner(address _from, address _to) external;

  function addOwner(address _owner) external;

  function removeOwner(address _owner) external;

  function changeRequirement(uint _newRequired) external;

  function isOwner(address _addr) constant returns (bool);

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);

  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) external;

  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);
  function confirm(bytes32 _h) returns (bool o_success);
}

contract WalletLibrary is WalletEvents {
  // TYPES

  // struct for the status of a pending operation.
  struct PendingState {
    uint yetNeeded;
    uint ownersDone;
    uint index;
  }

  // Transaction structure to remember details of transaction lest it need be saved for a later call.
  struct Transaction {
    address to;
    uint value;
    bytes data;
  }

  // MODIFIERS

  // simple single-sig function modifier.
  modifier onlyowner {
    if (isOwner(msg.sender))
      _;
  }
  // multi-sig function modifier: the operation must have an intrinsic hash in order
  // that later attempts can be realised as the same underlying operation and
  // thus count as confirmations.
  modifier onlymanyowners(bytes32 _operation) {
    if (confirmAndCheck(_operation))
      _;
  }

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
  }

  // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions
  // as well as the selection of addresses capable of confirming them.
  function initMultiowned(address[] _owners, uint _required) only_uninitialized {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  // Revokes a prior confirmation of the given operation
  function revoke(bytes32 _operation) external {
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    // make sure they're an owner
    if (ownerIndex == 0) return;
    uint ownerIndexBit = 2**ownerIndex;
    var pending = m_pending[_operation];
    if (pending.ownersDone & ownerIndexBit > 0) {
      pending.yetNeeded++;
      pending.ownersDone -= ownerIndexBit;
      Revoke(msg.sender, _operation);
    }
  }

  // Replaces an owner `_from` with another `_to`.
  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_to)) return;
    uint ownerIndex = m_ownerIndex[uint(_from)];
    if (ownerIndex == 0) return;

    clearPending();
    m_owners[ownerIndex] = uint(_to);
    m_ownerIndex[uint(_from)] = 0;
    m_ownerIndex[uint(_to)] = ownerIndex;
    OwnerChanged(_from, _to);
  }

  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_owner)) return;

    clearPending();
    if (m_numOwners >= c_maxOwners)
      reorganizeOwners();
    if (m_numOwners >= c_maxOwners)
      return;
    m_numOwners++;
    m_owners[m_numOwners] = uint(_owner);
    m_ownerIndex[uint(_owner)] = m_numOwners;
    OwnerAdded(_owner);
  }

  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    uint ownerIndex = m_ownerIndex[uint(_owner)];
    if (ownerIndex == 0) return;
    if (m_required > m_numOwners - 1) return;

    m_owners[ownerIndex] = 0;
    m_ownerIndex[uint(_owner)] = 0;
    clearPending();
    reorganizeOwners(); 
    OwnerRemoved(_owner);
  }

  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
    if (_newRequired > m_numOwners) return;
    m_required = _newRequired;
    clearPending();
    RequirementChanged(_newRequired);
  }

  // Gets an owner by 0-indexed position (using numOwners as the count)
  function getOwner(uint ownerIndex) external constant returns (address) {
    return address(m_owners[ownerIndex + 1]);
  }

  function isOwner(address _addr) constant returns (bool) {
    return m_ownerIndex[uint(_addr)] > 0;
  }

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {
    var pending = m_pending[_operation];
    uint ownerIndex = m_ownerIndex[uint(_owner)];

    // make sure they're an owner
    if (ownerIndex == 0) return false;

    // determine the bit to set for this owner.
    uint ownerIndexBit = 2**ownerIndex;
    return !(pending.ownersDone & ownerIndexBit == 0);
  }

  // constructor - stores initial daily limit and records the present day's index.
  function initDaylimit(uint _limit) only_uninitialized {
    m_dailyLimit = _limit;
    m_lastDay = today();
  }
  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.
  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
    m_dailyLimit = _newLimit;
  }
  // resets the amount already spent today. needs many of the owners to confirm.
  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
    m_spentToday = 0;
  }

  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {
    // first, take the opportunity to check that we're under the daily limit.
    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {
      // yes - just execute the call.
      address created;
      if (_to == 0) {
        created = create(_value, _data);
      } else {
        if (!_to.call.value(_value)(_data))
          throw;
      }
      SingleTransact(msg.sender, _value, _to, _data, created);
    } else {
      // determine our operation hash.
      o_hash = sha3(msg.data, block.number);
      // store if it's new
      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {
        m_txs[o_hash].to = _to;
        m_txs[o_hash].value = _value;
        m_txs[o_hash].data = _data;
      }
      if (!confirm(o_hash)) {
        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);
      }
    }
  }

  function create(uint _value, bytes _code) internal returns (address o_addr) {
    assembly {
      o_addr := create(_value, add(_code, 0x20), mload(_code))
      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))
    }
  }

  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {
    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {
      address created;
      if (m_txs[_h].to == 0) {
        created = create(m_txs[_h].value, m_txs[_h].data);
      } else {
        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
          throw;
      }

      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);
      delete m_txs[_h];
      return true;
    }
  }


  function confirmAndCheck(bytes32 _operation) internal returns (bool) {
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    if (ownerIndex == 0) return;

    var pending = m_pending[_operation];
    if (pending.yetNeeded == 0) {
      pending.yetNeeded = m_required;
      pending.ownersDone = 0;
      pending.index = m_pendingIndex.length++;
      m_pendingIndex[pending.index] = _operation;
    }
    uint ownerIndexBit = 2**ownerIndex;
    if (pending.ownersDone & ownerIndexBit == 0) {
      Confirmation(msg.sender, _operation);
      if (pending.yetNeeded <= 1) {
        // enough confirmations: reset and run interior.
        delete m_pendingIndex[m_pending[_operation].index];
        delete m_pending[_operation];
        return true;
      }
      else
      {
        // not enough: record that this owner in particular confirmed.
        pending.yetNeeded--;
        pending.ownersDone |= ownerIndexBit;
      }
    }
  }

  function reorganizeOwners() private {
    uint free = 1;
    while (free < m_numOwners)
    {
      while (free < m_numOwners && m_owners[free] != 0) free++;
      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
      {
        m_owners[free] = m_owners[m_numOwners];
        m_ownerIndex[m_owners[free]] = free;
        m_owners[m_numOwners] = 0;
      }
    }
  }


  function underLimit(uint _value) internal onlyowner returns (bool) {
    // reset the spend limit if we're on a different day to last time.
    if (today() > m_lastDay) {
      m_spentToday = 0;
      m_lastDay = today();
    }
    // check to see if there's enough left - if so, subtract and return true.
    // overflow protection                    // dailyLimit check
    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
      m_spentToday += _value;
      return true;
    }
    return false;
  }

  // determines today's index.
  function today() private constant returns (uint) { return now / 1 days; }

  function clearPending() internal {
    uint length = m_pendingIndex.length;

    for (uint i = 0; i < length; ++i) {
      delete m_txs[m_pendingIndex[i]];

      if (m_pendingIndex[i] != 0)
        delete m_pending[m_pendingIndex[i]];
    }

    delete m_pendingIndex;
  }

  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;

  uint public m_required;
  // pointer used to find a free slot in m_owners
  uint public m_numOwners;

  uint public m_dailyLimit;
  uint public m_spentToday;
  uint public m_lastDay;

  // list of owners
  uint[256] m_owners;

  uint constant c_maxOwners = 250;
  // index on the list of owners to allow reverse lookup
  mapping(uint => uint) m_ownerIndex;
  // the ongoing operations.
  mapping(bytes32 => PendingState) m_pending;
  bytes32[] m_pendingIndex;

  // pending transactions we have at present.
  mapping (bytes32 => Transaction) m_txs;
}

contract Wallet is WalletEvents {

  // WALLET CONSTRUCTOR
  //   calls the `initWallet` method of the Library in this context
  function Wallet(address[] _owners, uint _required, uint _daylimit) {
    // Signature of the Wallet Library's init function
    bytes4 sig = bytes4(sha3(""initWallet(address[],uint256,uint256)""));
    address target = _walletLibrary;

    uint argarraysize = (2 + _owners.length);
    uint argsize = (2 + argarraysize) * 32;

    assembly {
      // Add the signature first to memory
      mstore(0x0, sig)
      // Add the call data, which is at the end of the
      // code
      codecopy(0x4,  sub(codesize, argsize), argsize)
      // Delegate call to the library
      delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)
    }
  }

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
      // <yes> <report> unsafe delegatecall
      _walletLibrary.delegatecall(msg.data);
  }

  // Gets an owner by 0-indexed position (using numOwners as the count)
  function getOwner(uint ownerIndex) constant returns (address) {
    return address(m_owners[ownerIndex + 1]);
  }

  // As return statement unavailable in fallback, explicit the method here

  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {
    // <yes> <report> unsafe delegatecall
    return _walletLibrary.delegatecall(msg.data);
  }

  function isOwner(address _addr) constant returns (bool) {
    // <yes> <report> unsafe delegatecall
    return _walletLibrary.delegatecall(msg.data);
  }

  // FIELDS
  address constant _walletLibrary = 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4;

  // the number of owners that must confirm the same operation before it is run.
  uint public m_required;
  // pointer used to find a free slot in m_owners
  uint public m_numOwners;

  uint public m_dailyLimit;
  uint public m_spentToday;
  uint public m_lastDay;

  // list of owners
  uint[256] m_owners;
}","This contract provides functionality for a multi-signature wallet, allowing a group of owners to manage funds collaboratively. The audit will consider vulnerabilities that could lead to loss of funds, focusing on common issues found in Solidity contracts, as well as logic flaws.

### 1. **Fallback Functions**
The contract has a fallback function that supports both receiving Ether and executing functions via a delegate call:
```solidity
function() payable {
    if (msg.value > 0)
        Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
        _walletLibrary.delegatecall(msg.data);
}
```
**Issue**: The use of a delegate call is dangerous as it allows the target contract's code to run in the context of the Wallet contract. If the `_walletLibrary` is changed or malicious, it can perform operations that the Wallet contract owners do not control. 

**Recommendation**: Only allow calls to known, validated functions from a trusted library, and avoid using `delegatecall` unless absolutely necessary.

### 2. **Initialization**
The constructor calls the library's `initWallet` function via a delegate call:
```solidity
delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0);
```
**Issue**: Any changes in the library code could result in inconsistencies or loss of functionality, reflecting malicious updates. The contract should ensure the library is immutable for security.

**Recommendation**: Implement a mechanism to lock the library address on deployment. Use [immutable](https://docs.soliditylang.org/en/v0.8.0/contracts.html#immutable) variables where possible.

### 3. **Overflow and Underflow**
The contract performs various arithmetic operations without using checked arithmetic.
```solidity
m_spentToday += _value;
```
Although Solidity v0.8.0 and above handle overflow/underflow, since the contract uses v0.4.9, it can be vulnerable to overflows/underflows.

**Recommendation**: Upgrade Solidity or use SafeMath libraries to handle arithmetic operations safely to prevent overflow/underflow.

### 4. **Access Control**
The `onlymanyowners` modifier checks if the operation has been confirmed by a sufficient number of owners:
```solidity
modifier onlymanyowners(bytes32 _operation) {
   if (confirmAndCheck(_operation))
      _;
}
```
**Issue**: If the `confirmAndCheck` function does not properly handle reentrancy or state management between confirmations and executing functions, it can lead to unexpected behavior.

**Recommendation**: Ensure state changes occur before any external calls to prevent reentrancy attacks. Consider adding a reentrancy guard where appropriate.

### 5. **Default Owner Removal**
In the `removeOwner` method:
```solidity
uint ownerIndex = m_ownerIndex[uint(_owner)];
if (ownerIndex == 0) return;
if (m_required > m_numOwners - 1) return;
```
**Issue**: There is no check to ensure that the last owner cannot be removed if they are the only owner, leading to potential lock-out situations.

**Recommendation**: Ensure that at least one owner remains at all times when removing owners.

### 6. **Function Reentrancy in execute and confirm**
Both `execute` and `confirm` functions call out to unknown contracts:
```solidity
_to.call.value(m_txs[_h].value)(m_txs[_h].data)
```
**Issue**: If `_to` is a contract and calls back into the wallet (either directly or indirectly), it may be possible to manipulate wallet state, especially around the confirmation/checking logic.

**Recommendation**: Implement checks to prevent reentrancy and consider the use of the Checks-Effects-Interactions pattern.

### 7. **Lack of Event Emission on Critical Actions**
Actions like confirming and revoking do emit events, but there could be more comprehensive logging for security monitoring.
```solidity
Revoke(msg.sender, _operation);
```
**Issue**: Events that aid in tracking are limited. If there is a dispute, more information about who invoked what functions can help.

**Recommendation**: Ensure all critical state changes are emitted with events for better auditing.

### 8. **Function Visibility Specifiers**
Several functions lack visibility specifiers (`public`, `external`, etc.):
```solidity
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {
```
**Issue**: Functions without visibility defaults to `public`, and lack of clarity may lead to misuse if someone tries to call them.

**Recommendation**: Define visibility for every function explicitly.

### Conclusion
Overall, there are significant vulnerabilities in the contract, particularly surrounding the use of delegate calls, access control, and state management. The recommended actions should be taken seriously to mitigate the potential loss of funds. It is advisable to upgrade Solidity and follow up with additional testing and code reviews, especially through formal verification methods.","Certainly! Let's go through each function in the `WalletLibrary` and `Wallet` contracts independently, checking for potential vulnerabilities and critical issues function by function.

### 1. Fallback Function
```solidity
function() payable {
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
      _walletLibrary.delegatecall(msg.data);
}
```
**Issues:**
- **Delegatecall vulnerability**: The use of `delegatecall` can be dangerous because it allows calls to external contracts that can potentially alter the state of this contract in unexpected ways if the library changes.
- **Unknown Function Calls**: If someone sends arbitrary data along with the transaction, it may attempt to call a function on the library that doesn't exist or behaves unexpectedly.

**Recommendations:**
- Only allow calls to a predefined set of functions.
- Avoid using delegate calls in the fallback function entirely unless absolutely necessary.
  
### 2. initMultiowned
```solidity
function initMultiowned(address[] _owners, uint _required) only_uninitialized {
    ...
}
```
**Issues:**
- **Input Validation**: There are no checks if `_required` is greater than the length of `_owners`.
- **No owner limit**: If `_owners` length exceeds `c_maxOwners`, it should handle that case.

**Recommendations:**
- Validate `_required` against `_owners.length` to ensure it’s not exceeding the count of owners.
- Add error handling or conditions if the max number is reached.
  
### 3. revoke
```solidity
function revoke(bytes32 _operation) external {
    uint ownerIndex = m_ownerIndex[uint(msg.sender)];
    if (ownerIndex == 0) return;
    uint ownerIndexBit = 2**ownerIndex;
    var pending = m_pending[_operation];
    if (pending.ownersDone & ownerIndexBit > 0) {
        pending.yetNeeded++;
        pending.ownersDone -= ownerIndexBit;
        Revoke(msg.sender, _operation);
    }
}
```
**Issues:**
- **Underflow/Overflow**: `pending.ownersDone` could potentially lead to wrong calculations due to lack of checks or SafeMath use.
- **State Manipulation**: The if condition isn’t explicitly checking that an owner was actually counted in `ownersDone`.

**Recommendations:**
- Utilize SafeMath or similar checks to ensure safe arithmetic.
- Ensure to check and handle state carefully.

### 4. changeOwner
```solidity
function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
    if (isOwner(_to)) return;
    ...
}
```
**Issues:**
- **No check on `_from`**: If `_from` is not an owner, no changes will happen, but there is no informative error or event.
- **Require check might allow unwanted conduct**: It might permit an address that could be unsafe.

**Recommendations:**
- Validate that `_from` is an owner before proceeding and emit an appropriate event if not.

### 5. addOwner
```solidity
function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    ...
}
```
**Issues:**
- **No Integrity Check**: If `_owner` is already an owner, there’s no feedback or restriction until later checks make it redundant.
- **Potential for Owner Limit Violation**: No checks if adding more owners exceeds the maximum.

**Recommendations:**
- Provide informative events when adding a redundant owner.
- Validate before adding that the maximum will not be exceeded.

### 6. removeOwner
```solidity
function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
    ...
}
```
**Issues:**
- **Safety Before Removal**: If `_owner` is the only owner or if removal leaves fewer owners than required, it should revert or prevent the action.
  
**Recommendations:**
- Implement checks to ensure that at least one owner is always present after a removal.

### 7. changeRequirement
```solidity
function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
    ...
}
```
**Issues:**
- **Inconsistency**: There is no state check to see if `_newRequired` is legitimately updateable.

**Recommendations:**
- Ensure that changing the requirement does not conflict with the current owner's count.

### 8. execute
```solidity
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {
    ...
}
```
**Issues:**
- **Reentrancy Risk**: External call within execution opens the door for reentrancy.
- **Daily Limit Failure**: If `_data.length` > 0 and underLimit fails silently, it can complicate future executions.

**Recommendations:**
- Consider implementing the Checks-Effects-Interactions pattern and reentrancy locks.

### 9. confirm
```solidity
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {
    ...
}
```
**Issues:**
- **State Dependency**: The function relies on previously set states. If any state is altered unexpectedly due to outside calls, it can corrupt the flow.
  
**Recommendations:**
- Ensure that all external calls are followed by changing state only after successful execution.

### 10. confirmAndCheck
```solidity
function confirmAndCheck(bytes32 _operation) internal returns (bool) {
    ...
}
```
**Issues:**
- **Pending State Management**: The way pending states are handled might lead to issues if not managed 100% correctly.
  
**Recommendations:**
- Enhance pending state management by clearly defining transitions with state checks.

### Summary of Recommendations Across Functions
- Implement checks and validations to prevent incorrect state changes.
- Avoid the use of delegate calls in fallback functions.
- Utilize SafeMath where needed and address potential risks of arithmetic operations.
- Ensure reentrancy protection and proper owner checks.
- Incorporate informative events for better visibility into contract state changes.

Following these recommendations will enhance the security of the contract and reduce the risk of fund loss or unintended consequences."
